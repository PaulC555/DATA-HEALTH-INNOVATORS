# -*- coding: utf-8 -*-
"""Dataset_limpieza_IRA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zbgMoO_8j47d09ncPY6-BuGv-oMftQj4

# üßπ Limpieza de Datos ‚Äì Proyecto **Dataset de notificaci√≥n de casos de infecciones respiratorias agudas al sistema de vigilancia en salud p√∫blica del Per√∫**

Este cuaderno documenta el proceso de limpieza y preprocesamiento de datos antes del an√°lisis/modelado.  
Incluye carga, exploraci√≥n, tratamiento de nulos, transformaci√≥n de variables, y creaci√≥n de nuevas columnas.

## Descripci√≥n

Este dataset contiene informaci√≥n sobre la notificaci√≥n de casos de Infecciones Respiratorias Agudas (IRA) al sistema de vigilancia en salud p√∫blica del Per√∫, gestionado y administrado por el Centro Nacional de Epidemiolog√≠a, Prevenci√≥n y Control de Enfermedades (CDC PERU). Los datos provienen de la Red Nacional de Epidemiolog√≠a (RENACE), que est√° conformada por 10 232 establecimientos de salud del Ministerio de Salud, EsSalud y otros del sector en los diferentes niveles de las Direcciones Regionales de Salud que tiene el Per√∫. De estos, 8 483 son Unidades Notificantes, reconocidos con Resoluci√≥n Directoral de las respectivas Diresas/Geresas de Salud del Per√∫. La informaci√≥n del dataset se actualiza cada semana o mes, seg√∫n la secci√≥n de tendencia del bolet√≠n epidemiol√≥gico, y es suministrada semanalmente por la RENACE. Los datos y an√°lisis son provisionales y pueden estar sujetos a modificaci√≥n.

## Objetivo del Dataset

El dataset tiene como objetivo proporcionar informaci√≥n sobre la situaci√≥n epidemiol√≥gica del dengue en el Per√∫, as√≠ como facilitar el acceso a los datos abiertos para fines de investigaci√≥n, educaci√≥n, prevenci√≥n y control de esta enfermedad.

## üìä Diccionario de Datos

A continuaci√≥n se presenta la descripci√≥n de las variables incluidas en el dataset hist√≥rico (2000‚Äì2023):

| **Campo**                  | **Tipo**   | **Denominaci√≥n**                                               |
|----------------------------|-----------|----------------------------------------------------------------|
| departamento               | Caracter  | Regi√≥n geogr√°fica                                             |
| provincia                  | Caracter  | Provincia                                                    |
| distrito                   | Caracter  | Lugar probable de infecci√≥n                                  |
| ano                        | Caracter  | A√±o de infecci√≥n                                             |
| semana                     | Caracter  | Semana de inicio de s√≠ntomas                                 |
| sub_reg_nt                 | Integer   | Direcci√≥n de salud que notifica                              |
| ubigeo                     | Integer   | Lugar probable de infecci√≥n (INEI)                           |
| ira_no_neumonia            | Integer   | Casos de IRAS no neumon√≠as en menores de 5 a√±os              |
| neumon√≠a_<5a√±os            | Integer   | Episodios de neumon√≠as en ni√±os menores de 5 a√±os            |
| neumon√≠a_>60 a√±os          | Integer   | Episodios de neumon√≠as en mayores de 60 a√±os                 |
| Hospitalizados _< 5 a√±os   | Integer   | Hospitalizados por neumon√≠as en ni√±os menores de 5 a√±os      |
| Hospitalizados _>60 a√±os   | Integer   | Hospitalizados por neumon√≠as en mayores de 60 a√±os           |
| defunciones < 5a√±os        | Integer   | Defunciones por neumon√≠as en ni√±os menores de 5 a√±os         |
| defunciones >60 a√±os       | Integer   | Defunciones por neumon√≠as en mayores de 60 a√±os              |

---

## üìë √çndice

1. [Importaci√≥n de librer√≠as](#1-importaci√≥n-de-librer√≠as)  
2. [Carga del Dataset](#2-carga-del-dataset)  
3. [Exploraci√≥n Inicial](#3-exploraci√≥n-inicial)  
4. [Revisi√≥n y Tratamiento de Valores Nulos](#4-revisi√≥n-y-tratamiento-de-valores-nulos)  
5. [Normalizaci√≥n y Tipos de Datos](#5-normalizaci√≥n-y-tipos-de-datos)  
6. [Eliminaci√≥n de Duplicados y Filtrado](#6-eliminaci√≥n-de-duplicados-y-filtrado)  
7. [Transformaciones y Creaci√≥n de Nuevas Columnas](#7-transformaciones-y-creaci√≥n-de-nuevas-columnas)  
8. [Exportaci√≥n de Datos Limpios](#8-exportaci√≥n-de-datos-limpios)

---

## 1. Importaci√≥n de librer√≠as
<a id="1-importaci√≥n-de-librer√≠as"></a>
"""

import polars as pl
import numpy as np
import matplotlib.pyplot as plt
import unicodedata
import gdown

!pip install fastexcel

"""## 2. Carga del Dataset
<a id="2-carga-del-dataset"></a>

En esta secci√≥n se carga el dataset desde su fuente original (CSV, base de datos, etc.).

**DATASET DATOS ABIERTOS DE VIGILANCIA DE IRA 2000-2023**
"""

# https://drive.google.com/file/d/14PbvmNiqPcaUqOZDRoaZgFqY96J6OwLx/view?usp=sharing

file_id = "14PbvmNiqPcaUqOZDRoaZgFqY96J6OwLx"

url = f"https://drive.google.com/uc?id={file_id}"
gdown.download(url, "datos.csv", quiet=False)

df = pl.read_csv("datos.csv")

df.head()

"""
































### Interpretaci√≥n de Ubigeo"""

# https://docs.google.com/spreadsheets/d/1H1bQWv_7HQXN912xoPLbTgSseHu7zBbn/edit?usp=sharing&ouid=105796817412159770988&rtpof=true&sd=true

file_id = "1H1bQWv_7HQXN912xoPLbTgSseHu7zBbn"

url = f"https://drive.google.com/uc?id={file_id}"
gdown.download(url, "rptUbigeo.xls", quiet=False)

df_ubigeo = pl.read_excel("rptUbigeo.xls")
df_ubigeo.head()

df_ubigeo.columns

df_ubigeo = df_ubigeo.rename({
    "__UNNAMED__0": "DEPARTAMENTO",
    "C√ìDIGOS DE UBICACI√ìN GEOGR√ÅFICA": "UBIGEO",
    "__UNNAMED__3": "PROVINCIA",
    "__UNNAMED__4": "DISTRITO"
})

df_ubigeo = df_ubigeo.with_columns([
    pl.col(col_name).str.strip_chars().alias(col_name)
    for col_name in df_ubigeo.select(pl.col(pl.Utf8)).columns
])

df_ubigeo = (
    df_ubigeo.lazy()
    .filter(pl.col("DEPARTAMENTO") != "")
    .collect()
)

df_ubigeo = df_ubigeo.slice(1)

# Crear nueva columna UBIGEO concatenando los 2 primeros d√≠gitos de cada columna
df_ubigeo = df_ubigeo.with_columns([
    (
        pl.col("DEPARTAMENTO").str.slice(0, 2) +
        pl.col("PROVINCIA").str.slice(0, 2) +
        pl.col("DISTRITO").str.slice(0, 2)
    ).alias("UBIGEO")
])

# Limpiar las 3 columnas para eliminar los n√∫meros y el espacio
df_ubigeo = df_ubigeo.with_columns([
    pl.col("DEPARTAMENTO").str.slice(3).alias("DEPARTAMENTO"),
    pl.col("PROVINCIA").str.slice(3).alias("PROVINCIA"),
    pl.col("DISTRITO").str.slice(3).alias("DISTRITO")
])

df_ubigeo = df_ubigeo.filter(
    pl.col("UBIGEO").str.len_chars() == 6
).filter(
    pl.col("UBIGEO").str.contains(r"^\d{6}$")
)

df_ubigeo.head()

df_ubigeo.describe()

"""## 3. Exploraci√≥n Inicial
<a id="3-exploraci√≥n-inicial"></a>

Se realiza una revisi√≥n b√°sica para entender la estructura y contenido del dataset.
"""

df.describe()

df.shape

df.columns

"""## 4. Revisi√≥n y Tratamiento de Valores Nulos
<a id="4-revisi√≥n-y-tratamiento-de-valores-nulos"></a>

Identificaci√≥n de valores nulos y decisiones de imputaci√≥n o eliminaci√≥n.
"""

df.null_count()

df = df.filter(pl.col("provincia").is_not_null())
# Luego volver a ejecutar null_count para ver que ahora sean null's

"""## 5. Normalizaci√≥n y Tipos de Datos
<a id="5-normalizaci√≥n-y-tipos-de-datos"></a>

Conversi√≥n de tipos, manejo de columnas categ√≥ricas y num√©ricas, etc.

### 5.1 Visualizaci√≥n primaria

La visualizaci√≥n se esta realizando para ver la distribuci√≥n y analizar los psibles categoricos.
"""

# Tranformaci√≥n de UBIGEO a string
df = df.with_columns([
    pl.col("ubigeo")
    .cast(pl.Int64)
    .cast(pl.Utf8)
    .str.zfill(6)  # agrega ceros a la izquierda hasta tener 6 d√≠gitos
    .alias("UBIGEO_STR")
])

string_cols = [col for col, dtype in zip(df.columns, df.dtypes) if dtype == pl.Utf8]

print(f"Columnas string detectadas: {string_cols}")

# Graficar distribuci√≥n de cada columna string
for col_name in string_cols:
    # Agrupar y contar
    value_counts = (
        df
        .group_by(col_name)
        .agg(pl.count().alias("count"))
        .sort("count", descending=True)
    )

    # Convertir a pandas para graficar
    vc_pd = value_counts.to_pandas()

    # Limitar a top 20 categor√≠as para evitar gr√°ficos ilegibles
    vc_pd = vc_pd.head(20)

    # Gr√°fico de barras
    plt.figure(figsize=(10, 5))
    plt.bar(vc_pd[col_name], vc_pd["count"])
    plt.xticks(rotation=45, ha="right")
    plt.title(f"Distribuci√≥n de valores en '{col_name}'")
    plt.xlabel(col_name)
    plt.ylabel("Frecuencia")
    plt.tight_layout()
    plt.show()

# Cruce con ubigeo
df = df.join(
    df_ubigeo.select([
        pl.col("UBIGEO"),
        pl.col("DEPARTAMENTO").alias("lugar_prob_infec_departamento"),
        pl.col("PROVINCIA").alias("lugar_prob_infec_provincia"),
        pl.col("DISTRITO").alias("lugar_prob_infec_distrito")
    ]),
    left_on="UBIGEO_STR",
    right_on="UBIGEO",
    how="left"
)

df = df.with_columns([
    pl.col("lugar_prob_infec_departamento").str.to_uppercase().alias("lugar_prob_infec_departamento"),
    pl.col("lugar_prob_infec_provincia").str.to_uppercase().alias("lugar_prob_infec_provincia"),
    pl.col("lugar_prob_infec_distrito").str.to_uppercase().alias("lugar_prob_infec_distrito")
])

def remove_accents_expr(col):
    return (
        pl.col(col)
        .str.replace_all("√Å", "A")
        .str.replace_all("√â", "E")
        .str.replace_all("√ç", "I")
        .str.replace_all("√ì", "O")
        .str.replace_all("√ö", "U")
        .str.replace_all("√ú", "U")
    )

cols_to_normalize = [
    "departamento", "provincia", "distrito",
    "lugar_prob_infec_departamento",
    "lugar_prob_infec_provincia",
    "lugar_prob_infec_distrito"
]

df = df.with_columns([
    remove_accents_expr(c).alias(c)
    for c in cols_to_normalize
])

df = df.with_columns(
    pl.col("distrito").str.replace("ÔøΩ", "√ë").alias("distrito")
)

df = df.with_columns(
    pl.col("distrito")
    .replace({"MILPUCC": "MILPUC", "RAIMONDI": "RAYMONDI", "ANTONIO RAIMONDI": "ANTONIO RAYMONDI", "ESTIQUE PAMPA": "ESTIQUE-PAMPA", "NEPEÔøΩA": "NEPE√ëA", "CORONEL GREGORIO ALBARRACIN L.": "CORONEL GREGORIO ALBARRACIN LANCHIPA", "SAN JUAN DE CHACÔøΩA": "SAN JUAN DE CHAC√ëA", "CASPIZAPA": "CASPISAPA", "NEPENA": "NEPE√ëA", "CUÔøΩUMBUQUI": "CU√ëUMBUQUI", "SA√ëA": "SA√ëAYCA", "CAPASO": "CAPAZO", "ANCO HUALLO": "ANCO_HUALLO", "MU√ëÔøΩANI": "MU√ëANI", "MARISCAL GAMARRA": "GAMARRA", "RINCONADA-LLICUAR": "RINCONADA LLICUAR"})
    .alias("distrito")
)

df.describe()

df.filter(
    (pl.col("departamento") == pl.col("lugar_prob_infec_departamento")) &
    (pl.col("provincia") == pl.col("lugar_prob_infec_provincia")) &
    (pl.col("distrito") != pl.col("lugar_prob_infec_distrito"))
)



"""#### Normalizaci√≥n de texto inicial y estandariazci√≥n con el ubigeo"""

def normalizar_texto(s: str) -> str:
    if s is None:
        return s
    s = s.strip().upper()
    s = unicodedata.normalize("NFD", s)
    s = "".join(ch for ch in s if unicodedata.category(ch) != "Mn")
    return s

df = df.with_columns([
    pl.col("departamento").map_elements(normalizar_texto, return_dtype=pl.Utf8),
    pl.col("provincia").map_elements(normalizar_texto, return_dtype=pl.Utf8),
    pl.col("distrito").map_elements(normalizar_texto, return_dtype=pl.Utf8),
])



df_ancash = df.filter(pl.col("departamento") == "ANCASH")
ancash_counts = (
    df_ancash
    .group_by("provincia")
    .agg(pl.count().alias("count"))
    .sort("count", descending=True)
    .to_pandas()
)

plt.figure(figsize=(12, 6))
plt.bar(ancash_counts["provincia"], ancash_counts["count"])
plt.xticks(rotation=45, ha="right")
plt.title("Distribuci√≥n por Provincia - Departamento: ANCASH")
plt.xlabel("Provincia")
plt.ylabel("Frecuencia")
plt.tight_layout()
plt.show()

df_amazonas = df.filter(pl.col("departamento") == "AMAZONAS")
amazonas_counts = (
    df_amazonas
    .group_by("provincia")
    .agg(pl.count().alias("count"))
    .sort("count", descending=True)
    .to_pandas()
)

plt.figure(figsize=(12, 6))
plt.bar(amazonas_counts["provincia"], amazonas_counts["count"])
plt.xticks(rotation=45, ha="right")
plt.title("Distribuci√≥n por Provincia - Departamento: AMAZONAS")
plt.xlabel("Provincia")
plt.ylabel("Frecuencia")
plt.tight_layout()
plt.show()

# Provincias √∫nicas por departamento
prov_ancash = (
    df.filter(pl.col("departamento") == "ANCASH")
    .select("provincia")
    .unique()
)

prov_amazonas = (
    df.filter(pl.col("departamento") == "AMAZONAS")
    .select("provincia")
    .unique()
)

# Convertir a sets para comparar f√°cilmente
set_ancash = set(prov_ancash["provincia"].to_list())
set_amazonas = set(prov_amazonas["provincia"].to_list())

# Intersecci√≥n: provincias que aparecen en ambos departamentos
provincias_comunes = set_ancash.intersection(set_amazonas)

print("‚úÖ Provincias en ANCASH:", len(set_ancash))
print("‚úÖ Provincias en AMAZONAS:", len(set_amazonas))
print("‚ö†Ô∏è Provincias comunes en ambos departamentos:", provincias_comunes)

"""### 5.2 Normalizaci√≥n

## 6. Eliminaci√≥n de Duplicados y Filtrado
<a id="6-eliminaci√≥n-de-duplicados-y-filtrado"></a>

Depuraci√≥n de registros repetidos o no deseados.
"""



"""## 7. Transformaciones y Creaci√≥n de Nuevas Columnas
<a id="7-transformaciones-y-creaci√≥n-de-nuevas-columnas"></a>

Generaci√≥n de variables derivadas o combinadas para enriquecer el dataset.
"""



"""## 8. Exportaci√≥n de Datos Limpios
<a id="8-exportaci√≥n-de-datos-limpios"></a>

Guardado del dataset limpio para su posterior an√°lisis o modelado.

**NUEVOS PASOS:**
## 1. Importar el clima limpio
"""

df_clima_weekly = pl.read_csv("/content/clima_arequipa_semanal.csv")

df.shape
df.columns

"""##2. MERGE IRA + CLIMA"""

globals().keys()

import polars as pl

df = df.with_columns(
    (
        pl.col("ira_no_neumonia") +
        pl.col("neumonias_men5") +
        pl.col("neumonias_60mas")
    ).alias("total_ira")
)

import polars as pl

df = df.with_columns(
    (
        pl.col("ira_no_neumonia") +
        pl.col("neumonias_men5") +
        pl.col("neumonias_60mas")
    ).alias("total_ira")
)

df_arequipa = df.filter(
    pl.col("departamento") == "AREQUIPA"
)

df_arequipa.shape

df_ira_weekly = (
    df_arequipa
    .group_by(["distrito", "ano", "semana"])
    .agg(pl.col("total_ira").sum())
    .sort(["distrito", "ano", "semana"])
)

df_ira_weekly.head()

df_model = df_ira_weekly.join(
    df_clima_weekly,
    on=["ano", "semana"],
    how="left"
)

df_model.head()

"""![importante-108957925.webp](data:image/webp;base64,UklGRm5eAABXRUJQVlA4IGJeAABwTgGdASogA/YBPpFIoEslpCMhpDL5WLASCU3fjos1fTK5/8vrMLn+Q/tP+F/2P9y/bP5qa6/e/7v+pv73+3/3Tfn/+d3RdS+anzf/pv8j+N/y9/sf/N/2XuJ/NX+H/yH7+/QD/Tf8T/xf8v/jf14+Iv/w/5j3Gftr/sv2H///yB/nH9s/6X9u/fP5if+P/2/9f7n/75/jv+v/VP8T///oA/uv9V/7Prx+xn/gv+z///cL/m39y/9n/O9tL9y/+D8rP9e/4H7f/8/5I/6H/mP/p/s/3/+QD//+25/AP//1m/Xb/af27xOfmP9l/rf+I/cf1R/HPov8B/av8L/4OXJ1n5nfxz7r9x/vT/g/+d4H/lf6p/tPUC/FP5P/ufEj/1P7v/Ku/F2z/Qf9v+uf3z3Bfgf55/yP7H/lfY5+Z/Zz1O/hv8N/0/638AH92/v/66eeH4Qn3j/YftX8AX82/tf7K+wHoTeq/24+Bv+h/3jrWfvP///d1/btbKivMYe3cvSXbLorzGHt3L0l2y6K8xh7dy9JdsuivMYe3cvSXbLorzGHt3L0l2y6K8xh7dy9JdsuivMYe3cvSXbLorzGHt3L0l2y6K8xh7dy9JdsuivMYe3cvSXbLorzGHt3L0l2y6K8xh7dy9JdsuivMYe3cvSXbLorzGHt3L0l2y6K8xh7dy9JdsuivMYe3cvSXbLorzGHt3L0l2y6K8xh7dy9Jdnxrx+LBBX6SdoLNTTD27l6S7ZdFeYw9u5eku2XRW7HwpHMNba/k6YW1Gid72ZG/KcVN7Z7neXjCV0Eu0VNPkWI9u5eku2XRXmMPbuXpLtl0Vux8B5OVf2KAYYHj+xm32iJVQAr0qO8w2pKFTwLovz5CRfg0Tg9lfeE1RlBUd2xdvWx5UhyorzGHt3L0l2y6K8xh7dD8Q+1WMVuSH+KVRNFCL0unkzP8niX5ANCT0y6pk8mlptdVKbi9yikuFH3btIgsZ4VJmqnBd0Bam2WVFeYw9u5eku2XRKW+jR5wYwb0h+CW+pShzJ/dYzy2z69Ty4O3SdHkrN8wma9vG+EEVAWoxKcpaOV9A+SRalq3Bam9DCBUOPSe1IVbI1g2iUvAelK/Vuc4uJAf2F3aXqC3GmmHt3L0l2y6K1w5YUpqOQ/3+/tk3tnrObWEOta31FcLTfnl7KYu2UcpS2ZrSDbkZOc2b8JEdwjlFvZBXIIjMjtbgCnnVBLkhKAx66VDEOvLZ4Fv3J/zX6HQugiy5cX0Fg/aRq5xU6yu8KPY7gtm+dOXWw+l3Lw/RF5USPJjw9u5eku2XPAJ/ua3gbHky/+51ZR4geJfD5i9Pj2gx6pfZ/4Y6ldvRrv/xTNbgyB81ernwccMw/fYB532pB1Bgguw3ls7akZgUj0m4ywsyMrIjL6xoB6wxXXfDMz1W0kVH/jhs4UBuAT25qgidsANRD3al2en1JChjcfQDgmPyYRWlCBGmHt0P3+PKP3F6R/+wMhYZKFPV0C4j0T2IwoZltU3mELllRHwfarMnAoxNgM1ZWI6PcGHEoJHgqk/cmhyAwxnGvyoOpRXv0gyxnSJZl+YsvWVEIsLZiPUMdRBBTbSx9b9HqZY+AkmuExXt9UVfNgzQFoEEhCjhsjULYekvoVgFZh7Shosr5w+1DycReM9QKQFYAGqGzTeLDfr0dXvf/ql7MOafj4LgRmyyUHQWEj9M8LkJV9m0D1oRZ1A9J7NjQQecaxcAovRw+ssVJaeNdkphobzBC5ithm4l1LArZhGm09aOV5KOCPjxdDj29Iz2Ps++jMD3N+HIMOrSIMdggsKrkGCj+Z0fx0r/Xj2fhOOStuDf8Io3aSQaifxStuekVHgN0bjz2PoZJj3qXsg0DT84hRuf1x9ZY0Z19Ln1gWija+5tQ+un7a6HI7/e+yIi+vfEpGQcai/Vp1JdDLPPFTLl/UQY25Zd77MwJURMs6GDFUe+SC2kNSeMnmVa2/hIhBS/CWxtBHxKkpAOJeI1A1IWNNCn14VeNV3PqVpYV1pPx+4TwwsgcpDZYsVk2uS5S3Y6sVQafumirrhdg0y66Eb/E/mPrH8/pfeIpCn8bwfWk65MB5uTCIpGUzZIJ015i9Bmeg1yby9vyXjcV5hX+rq4mEiVnbLi/vaSrwSLyKNiqTpoBzKNr0BRlaeXQ9JlgJzMBJSzv1bHDmsV1qC6L2mobJzLptkITTLtJbbZDhic7z7fO0sbS+jEqKnDWNwG96rMrSUsuOuvD512RigLWFSuNQEfI63j33VqyaYz2KNml7IUUEPMHi9PhBMBcR27XB3NnHtz+sOrMmtqLW5Rjxrm4w/MrbDKxXo/f9tA05V0Ial0mP9PHPIRD9U/pdsZhWBkny5dzXhBRc/LiPpSGuuMETENVfnkMFHf83ZJZOz+jcoQxSne2PhqPz9HJ8ZN4MjCRvbKVtYCZ/5XDvtemQdlAPt0EauGMiGNdoL/E5nAhUtSlFoau62qHnFzNl07jxwiwWAJw9nPjmx6+rbjELlHPfW6PCIAmiwSx+VikP36QMddgT1X60DkDAG1/NrfX73O5wE5aWfM5rCs4+Ma0JEm55Vd1SftdE8u2XRKmlKJmPAdY8HNSc7Din56ufXpqSgw05n70TSefIzam99gScIQ7+p/aYUab9gWv5Hzm+HkvQUa3dKWIl+cWR7Q7eBkTv35eaBCFQTebsv65ti3zZLW2i7a/m2EYHFgiggKpohNiF3cOwzyrsqgzG/f0ZUBAw84chqVuj8vSXbGp3AsbIMxGgNKDXxiPsaCJgxLOg3g9/aeD5SiGYMbmAlRxNgq0df8t6aC/Gd2RGpA8dLF+AI3PU5ASub6fAdBJFjMo2N73tn2zCLaRkuLqESeJG7wXKOb1CthTy7ZdFeYw9u3oXsA2SmSawoTh723yMD8/xpUgFj55JtTYFNDzP9PoHwxOVWtNMmDSeX/WgY+QXg7uGdY/trxYQ6v8hBIM24r5hHYmPm/+3b3mZR6tzLXqscspc+yorzGHt3L0l2y6JB53Ak+HlzoROlzdJAyr6Yo0ApBk1PlgORAxu6rEomSwKB/6V8D4r+KhbZ3DPwp3fan6wYA3nKIJilHG9JsH63ijWFErz6NOKeVoWYIUVy9JdsuivMYe3cvSXKDFTyl0mwhP+HKzzVQFkl6uWb6BjSkzhNrfKVD7ftB+gqTZiK4t4Idp4/RAxh7dy9JdsuivMYe3cvSXaBTX1LC7NhDE3xD4O2JoFnXaqRvKHwiBOQz4QcmeJy5+4u2XRXmMPbuXpLtl0V5jD27spmPfoAL1qILu+Pi+JKb49svY0zGr9qMal/fs8qm9JdsuivMYe3cvSXbLorzGHt3QDAfv8zjD27l6S7ZdFeYw9u5eku2XRXmMPbuXpLtl0V5jD27l6S7ZdFeYw9u5eku2XRXmMPbuXpLtl0V5jD27l6S7ZdFeYw9u5eku2XRXmMPbuXpLtl0V5jD27l6S7ZdFeYw9u5eku2XRXmMPbuXpLtl0V5jD27l6S7ZdFeYw9u5eku2XRXmMPbuXpLtl0V5jD27l6S7ZdFeYw9u5eku2XRXmMPbuXpLtigAD+/8sQAAAAAAAAAAAAAAAAAAAAEqpYDaWDugLc/JR67y2pkPSACQYb5K4utJEwBc6Bqmb7qAyr7jt3iVYvfnyvcwQtkHkdMhoyqrnOS+Eapffn5yVKQ3VXIuKxl1tL3Qr4/q/Kb4vICIobTbv20z0mC9W49TAA2wiz3Himo22wKo6JllR4DXY9FVK1eqqyzSlLTfZ73n4OimAARgqSknsJpxGDAC4hTRuInTbCMeUj/NcGfoeLWQc7Uu7fryw8aFxuL3MPPEh6e+aVdl9gacK8i/UarR6DGzeoECurcBMv5100f3y4iw04kQCe0nc24+JPdoJxmDGNlsQuTWAyKiifQ17bagrc0zIlTPBQN0bhUyymv0mFi5YxR9cpTPgZoSU8aFf8yxCqTKUs1zol+zRxT0Su7UjWMsQwLrMNB8F2uFA98/biI8d+03ZXNkSk3+pCMUrqhBwCYSS6KlLYrNWpg+XJMm0ReF1GftebhWTJ68r7hshC9FSIPd36zBC1l9VNN5uX97/1fROZQCIP+/UoFIW1Gx3K5vu6fU2xYx3VJCXUGoJ2lBiF0yIEyCwDnbTQCaJgjLy44EMKPnujVyXpoDqJbi7LOR8eYpc4tZ6Zr3KXKkOKweDMqeFz+2xPby0p2fD2K7kH1Ed3PGEA/XrHWZFPm5MDSQc9ncC7hP0MK6e/m9Fr9JLOxosC2YLxxPUD+ylcydrjK33uha7iuL1BYFcsk7b3ERbj3a+buPnjM6YzJBOInKGO9Sgb4Ai5w0/Wz4R+HiVMW6Vvd1uzNxIHG6d4AAzu2DUzILTPXjzQjs9YFIsLgJ3+3fHSl8rdozkbpWrvAAC05Jg0XBky/4Jf0umFP1LQ3gOJuyVbq7sbbbt8QyBMwNhJOdYvV9R1RHKoGLKOCbg8vaaVvMk8lqcpNOiln7pP4KSFr4CIfAb7AM9Ra0+ZarmVfXO8vaRiQJo1bUL6BXnlls4TkBAf+4JHxluHNPFZoP75HNpOC3LaunQFJoJ4OmImC6vp2S/ZuCnYc7QVZSIsEqyvCHmSqRMVD8JVbF9EQuZ0g1ss6k+NExoOhcW5X4gSY+Ya1GJVBZUPzny/f14/uDbgICcBqqFF6mBsXl/fnpYEdxOz0no+ZqTjuoCoidg8Oq9jfSoAbCHSSkxQMt0DaMiVUv/+a4ys7WWKV18vTqUBK00Cf9lD3rf8K9VIbdrbKENW3i4w/07++bETAcpoVGZUGUDQl7yVrZ1AnEFUvltmLmE1CrL7q1ofQZcJTxBOET9MawTyvL9078yp/+XRoieBwQk0qHw5BEiYN79gDeoZYdJCh8KnLTpqtGnn05/Rkfy0yxKl85wgDKoqOhQISWJYToTMgcxAXs2GSN0o4EQGCsmw/McvNDDwNN4gBsGwiQ5ROeG6AUTt3Ajq3+8XkQi1cgXMKGGsgRW0rLVemjq9Bxhvxd+7Bp7fTQszduDRvT/73HFMzjUwxnPCO9jK2Mvq/xQrJomwnAFe+PdtxgqydWiNZmLbyHGiBK315BXn1EBymYw6VR365l8o2BOl7bFSw3qkNO/ERFchcCehe6l45xXW02bDBJXSVJvh+LxbxXgyA1Nu2jwB8/T+lm7GEMRklpDHPnrYfkbME8SnP9gxcnvdh9yE6qBPsSxhj/gp8m7GamoWSudYsZuOJPZaWTo/lAORCXqLOUvESVLVfWJU4ynfQYZLvdxxPGhM+QzoILzMEND5sxZ1yGlidnTyhqQj7YDgTqbxofgnOKoL79gmTb8AJnydwZBFpDwqLXtupKFdAtng42VK69/sTWU2JbUButvgqo8BaQEhtyle2aIf7LmuDRLmbCWP33E7zht+viWc0D4o6BOTqvap6muAopSyeipvrDLXXLNMKn4cqZadW2KDGOnB4jjJYjh6U3oiQLC0oVNU6wquvOtz+2CmwIKNewjmuPNdrka4jd0bcGea9jsBdne4t0yOLlzyjirzyLtMzC2rm/B0yS/3N5HbvaBklyooPfq8/aqW649gVsi5OZgd9aIPR6g+zegVgJkNvFp2tY0ReEnpoHGc7VXxC/sMuHBeDjADoGIbc8w4xOG5r5mLNtTSuAfBFRdi6cFNhdPKaerOdEVu/NhI4Y0tz4Dg3vFATPVHIYRec3Z59xEOhJOK4IMeKJ5ipWbShgAJGe6g3Z/Peq8jM4dXoa22YjemYXvEFTg2QjyksZ13+KYIk3PDfuNWZUn/r7iCEYNbPqncK/d3eKlunNpVy6uF3pPik4xBC7PnFq2pCI9XlAlUHWFI9v1GODMWjwiq+n2nLl8XdttUM/XjYqAqU9iJ854t3lQoMCFSmWOYu8WZLtAd4YvPs3+Xs3Cx+opYoi4UjOZUv8AdsWMftCvq3MRU0gwmsEQ1mBTgO837t8MYGh55MIJaV5cNMYY2OtEbMMCe/v6c4GfXqmlmlKWEZ3DMAcgo8NUS+MPcyPMU/XedpS+oNozupbRrKYJnH4F5O9LSGX7F+ika8llTUlH/KcMwFRvyJDPI1FpIw6rpUBreW92+Y7WTukJeJDno9coa/wWnZX5Xig4E+2QG3IgpaO1hm/AMV7qaX/g05iWgYidKpnV67UhAoLrwALPE2qu0RmjplApnPWMpfXCNIbRmFPDsuvY0f53J3UW1e4x6SrYvXyHtBgQyUk9arZMPMcoHDnOg9SeRa1/AmNU9XWW9jNCH5G1T2w+Ss26qoPIdhl03C0fIM4yA16bt3jfKTwvJ2YidAgsYBs2erzdcxkOOPkR0RKju/QRnh6mVjGtgf8spHlu09SanlCp2nq6ir33/EkJEBiGcaVRVYuphqiPmB8p5400r9GD6axqnDOB6u5uuawSq/MJmppBkyI9oRDhKXka+D8aFIF+pT0bPnUGigdyUwbkhqbdImOjn+wZ+tH2C8NtnMHm7lqnpf22GfBjvO9s9xkPj93KLiZdh+y4NDYhw94jMlqv6tfuyaCizEHNdmOwafwT9FS6DPQieiW+P+XIucBSvyZNqzSzgixHB0r4rklNo/k4dSQesVhAwFjECKNO/leDv+NZterTxCCd3bI9xjuTUy/EOSTdGGJLxAJWyCnscchXvgcFQoqmQ7f5YAiQRw6qvVlNXVqE/5Eztp3ANJgA7Vr2KmKdhDCLwEbq2HAy2+XFELFTk0vlYpWeXORi6MyrrQOlMLXZclN/OGL+o8w4KKZs/P7/1zRQZCDjoF/bi/S7A6Rb0HL9y/XrEVSIxzl4Zp1eoHrU/jorZa5CSRCZlA6y5RkRi+8KR+1e9S836RguseCFaVC/t9COKiozEiQ5E8BVcwHXL0Hhxf5zHyitiiJQQw3dx8wW5+KXMJ6BV79MNOYLFUYJD99zbpOfmkLmupMnq6l498tKKgewMyXuSd8ad8xKl1MUJk9T1g/8YLlH9W+pjlJX715vdnUGuq03zDftU4EVBAvZGHNwUDWji0Z/VwqM4fvHLenYQgh5hrK0vQ1YsQ6ldV+pU8whYt2YE4NZlHrSJNQstcgJ41FEQRHTAduxlHG8eyJ6+1qCJE1TckHcA2amqCMHh1BfvVD1sRontRqTo0q36+fzGj86MQkBz9vpnMP1j9BK/rCO+6YA1l5TZFlNPF38m4e71PbP67rRodkt1aXtpIsnWn7nGy8oKlAsj6WqHLurv256guUqzjwPeOSOlVy5J1DhGNA2jzQUbEceVLktYT9yOcxCTL4FN8eLFIt16VUP4k1ByqZqMDr39HsBq/kKHW+kq+kGJ0IWj4Pt6AwRKswvoC75D9vqQBvjQOeyRJyrzDkZ071SUX+9INF7Wj1QZva7+ajo9uGgbz2QsPnZXqcHxqGAMCNgLHeoxgQ2zZhHKmX1KozyFu//t/eixX6gwjBbF7lVcLNzhjlRV+OQViZPz4tZZiRhh+3QLreE5rDw/VlGUWGj/Z/coAL/Ae+3SaDrXzABnKq6uxZv3PDhYMu/yJnYxOgeab5YaM328ZDPn7wDOBFCb0NFwoisscjUXcsw3sT4Y6TrdoTQFYBhnzLnpFvnn93Inf7alN9QTgH9iGATQ081Vfh1QO2P/5MofqBSrbzM9bQUTONRZUcIQJYjN3ClQLJZTJD4MTMpuE8SSunPgy4sgVkCodNT2xm9EsgN96dUcNk5LgsqSqIbbhtjUixUGe/qJKBPRhshAsQolotp9kmsKXSMmO+CUnpl+L0nEYag6gzi23r3P5xlqrfW3vwdj7bTDcjfcvKFLsXZtN8SFnEbG4Rcm2FvOIJqBKqIkz6hVmvDOVVK4jfqMC9F4KMK9sX5G7XuNz8Xh4hJkQRCRR+/IJJTXll4l9MAgILw3YxE7JMZWUPeNHzwVzhNV/y0L3AnH0Fan8lBYQesTWByS9Nv8oSgxyJysW1thAOErgqUetLihJmCMc7mNzl/3wty6x/iegK2zCEq2PT6Bo9uHBL2+4fjKZgTQjYCvpcD4u870nZT1RVBzylsbCzeG8XlkrjBTwFZ8oD6knyVMAT3OpzUb/INHDZd+AragI1hTLt+cqJ/UY0AoQ1Jjk1MVVKLCYNUxmmAwsxQMKDTe2HHelp/SY/IF6VVe8cL5gvVv4WttnHRNLglUfsQdARHN5oCh+KSC30txLKlxJIHxAoDgpRI3TmYDjyEo5Mov++tOEOI8TwcHw6K2ldsiO8IctZITp0XPGZt4/3q4MnwKIEf01iXL8DPuZR2DKmdRFXbdKxx0M1MUTVybHRn3fXiuBxtNI6erBrQeoRMv9YgImqu9N8NvJKETlKPlsVN0wcscfZ3gQSd/wmNiB5XYe9cNbwuXAgoiJy1qE8GqLlAGsotWeX+KqOxK/a0APFAjacqKT5Qca69J4xROGPJZtbcsNXhN21yv+VfnEvR5RgiXY92w/i6qFevEJI9UJa8Zqlppo4fsDhqCZ9FTYSKuMjlbG+JoXCO26bd7dxIkRkzfDMJ+FzjskTo2f8pDPQy1egVPeAsRDNKraQdWxTbyb1FmhoHexD5wvAurfYTk/0i8Xpar0o4ON53NI5xA4UoxPwx6qzNrEUA6Q6KO3c7KK4z/msZOI7I2L47FpKYulDxeFHsqo8EwYb5G/fxQhKEsVgLKBOwPWpldHfI3SZuBXPbP/KMbe/MF0TrOORn6WQaLNSb6T8gbOrryGvCXodYKwaonL+3nIIR6wdOa1veqIdyW6pMRBAQjo1sxYpCK5QK7dDKcYjj/h/GL+CYwtEglO/yxhf8gknCf5GLHiZmW1GOdCh5c/4sBe9JfdGARsjlVkQ9KH0WzCZsybu12O1/oWCszJbgkw174Gnh0uS+JV7jsEh/NreqE6vuiOL1xneOJhUjTQdKyGkzynbgB758toFpcQvzArkzEn2Kp4qo1TTOuZY1YKpdrb7cb3NWzygkZzOrIUjOorzf/TA/V1vABEpuKFkQgHtXH6BfmnIxN9ilm5CBkEsqdCF1a/AomtTKP0FmtkQrU9CCtIx6ktqkcL/loTq55oIjlINoK7FQ8s5GnA7+usRMO1BQYX2MtQeqEDns9cxelIs/TlMklQLg0ZVgUZPhGjYCBS06pXeR9BywMQv82f6ISAWW8omiZjvxrLpo/X9iHBAfMaKXoGG8RjD5FDDgxyP2KNkQGOaEs8xTw66IyiZX+E8oGFiia/+V07rVM/u9pxSHCp28HHv6Z/Xhjk3/p7vwsn1X5fLW+dtOxWY1NMNzs7/8DEOXbpCXaiCNl820YSgGBXk7QTSj+rIqV4EJwz557aZi1GyfhpBg2KIPvbDjDhk2Zs+EJjZnVJqE0dDqkpBAq/xoo4GPD6ii3wfVlexC1propI7BzL/Dahb0KaEgCMbRKgGtyYIrBN2zdBpLi5TYbQ6Otny7BwmnRq2W74gLvdc3U4KvmRfrfvcjhhxexkV2zoG0DNFRhkF8YLF0nR8HwdOMV37vS0V66HdLFs2+ACUFSkKT4sG97CJIauQ3a7PYCoxhWDgwRsNKksP050PtcrTPWYMdrXWVBrugUpHxi3L/W+cisBCnwF5Io23dZ8PKaBultxFFVJCDYLwrD7/dXHGNZcCJs5UxtPkYKQHNhzjyf10cpiKSo8UtCP9sScj53gQUmnr2XAV06jPpQVmswLS3MQlbPkdPKVOzR5C5Zt7GjemNg75XTfbVUqChlEelPxrXKMHCpOzo8BTsQcZ7xDgmeV7muJ8RWFsOMapyw0t03FNHqppIBk7s/V/6A0U8fWKstLk/AYBVDa1CkWxTxmAWp2p0e0g/iZpytvTgnOSjER+jHv1mI9E+741OpR05oNGki8yWV3WzMH2pn3GVVWnff4KzvY7q+UUn9fRMJ6S+FeMlFEMDP2I/sgQrpj6xBPOTTxXhokq1YZC3YIPg/tJCoxp0NWe5XjxAOnieTlmrRQgnQDUpVEtBeeLbbxFbTDPV0XIBMlC3zWXLAF8ctrAsgvcagn2tQ2eDLguH4ZSF/Zp0oEs2b+MsmVR6T1ZSOZws2wnNjA2z/RzAnxn7+4mvOPN1vI7lk9JMFjpV6FwF1yCk5R5fmbYVivhNKW34agoXy4g8DWjzBC2ZtnwCNR5Tz4nYLjw2e9DHoUc6oTWEvwT6IAKTIXJNTaHrQRjOLotbhjL2kYsg/PbKASDZUPqRmSxnx3mFrGDhzUm1+0L8iFOt6sSAiOvdgJkxrvKaaDIobT113w9hChZvxMaJBS4k1OK7P/tAWwFytGUL0UicFx4StSZtwCCy6J9GTToaEkH5wm58MkftgjVrrk0EcCOzWG+unhbnTzJ0phsN8XgV0R1t8r2/9qWTCaq7tUmA4CMcrLrn3HTIV7I03HfnSBqGXQx05SZ2E5ZRutdiMB9MjicFXs/vCxxHk/qU9atP+NLOwcYRI5cTYfcLbohP6d5+d4fZKfGwvehrZhAzOSnPi4+58mwdCBfykUl4AmeeHCMP5cdjXf2pA/q1plUl7R0kIy36zb1SDZYIPbsPDacD2cU6Msd5YriEbtqCc2yeB9iNuHIC+KpqMwi5buUKEM6GiUMXC+8/9NBx7CBV8FGE7b28gmnmVrBt+OJ6r8UZADDuP7lG4obqalLFIBr9VrtiNtw36gl0epmDUGRuLMVGvg6qJufkWl5tkBaIdBEhmNBW7qJCW/4dJGRYAfwy0hj+9MlCqmsq+H3UlKmbI66NQF4Iv5UJ2IW/ksVOJox4+JuQ00UIYk8UrTexEAJdd3FxyM/FhZ7rLX7RySAIfslNt3l1ZAGMmYIY7jvsUaUsuENaSZGhqorBBrNC9/LFVAbpkJ7IPPMm3JIdKyByyrqHQHjbnV3vgImR9dTCRdCpZ6KjzCC7C8TWR6aS7QYnb5Gd07+ikmup/8LImfa/mmr/WMhtwq+atO9mNB0Dl5tI3vJhVHgn/6UB0+kp+i0fFKVpVMBGi5f765CxUO2yHeDd+nxaW56PPKGAHBPFiNc2LzXOCboHkQa2Tnp0GSHEOsf6kM6e4St00PU9abdUh0stBarqJXjpyd0ralh3BERJsp880XMvG6+jT1R395/t70qiFoKH7TDaU9av+/B3u/a2jg4XUD4K1hwiClVJ4jHrWiRsVMMzl8O0B5Bbn2tbIfLKgkbn11TXeOfnGGzgBQULQjq6eID6rFvTr0TI3rfzbmHE34SCu2LhngoQhWEMFyyF3P+yJgXire5F1KeYXK9xvjihvG3aeha2yMhg/p//drsX9gveAqGjikmZ3UqxEmU2yTbObufD0bEb/Iry8pM4cEzVdv3YhigKRpHcljOMjW6h3Nu9FPHgG2sC/ZuEw5+By0CcfvRNHumAFDJE1o7duvQbGwziF5KVPX50vJpwKGzPrENRE2PUNjbOFt7q6I8IBCWBiHQTtaZjAbi83OS+NVBd0XuMynkLgoYSn/h1N30cKPLHJBIvpvWKgJQg0cpAGfAhLs1oW5/fFhyKBFEjR010joTJCHOMZdDllCgzmzm5qojzxPO+uvVDm899HYq3oaY0S22/KVGEjiwwzN6qZpeN0A94W5cbc4sAcYY/BqK1kZWDkVUQifD0hEB0TWsqD6jfRdwm3XTYbG0ZMMwmZiDgqxUD142OCGnzQSGAUjsFMbM4xCPK5rS9OqOA5AhBqHc7shi5HIQ/3IHd9h5TgLgVpw9LtOoaHTxJIXtjjl+chwWr3fbOJk6qEMoRdzsUqnIfrSV/+74lx3DK1DkvZ46/NZIwAWtGV44W6VdlHhp+b0bRFT8FPw4wKKjz+duVhcACLky77fAb4L583iPxhtP9D+f37tyPBi08EN6RGJSaM+sDRf4u3TpAIWaYAKvvzMmKq+CcmWNThmAK1YG0l7G67FgbQBZGEJ4mYfXLO1VAmfYOyXkCAd9sAFA0cA9juevfX/7pFgXHapGdROA35ODqaCBaCkF6Jc93yn1xeWAaPfvH+G7qcfbXwlNOTPfHLhEktt/83Ab4sfZdMzHzK/yQH58xWb5chom5UHf6X1YzekKxtVQSTiaM4WbYTmxgbcFdQrGT+/vrnexyXm61zShQgC6iqh1+SIMFhMlvRrn6owoh2JvKleCRuIdxpgitCw6TldOoNEpOoCpDhArXGZ/g2Ud9B/1LHFqxWDKs/fPhXyqM6ORNPlbwvhV41w980x9cpNTBH9m2xM1/40EWXjIAcfR9Hb7rSkn4jBLOGKitvIcVbwuXlV0BE/ZsqxI27wzBLpCSxCdRS4sC7yMCnsV+JNe29xQu4LMdk3u4924FfO344eLeGKeeQfMbdrQuSVf+DJdblvHiB8xbbaJE2r98RZzxWSkyjoJSkXuJfuUO8wEVxzkirLdl0+7jyrtO1ao2wOaMKXzQ0sRauHaGvYkGMBxMZmmpsbB7lxkC0vhM/cwqq15BR0/rZhSorNfQIvz6zdhWooPPn6YecCI7JJf7TQXX9MyxuiNZYF5bDYtVXlFx8ssJp9cY5YoNuJ1k5SRAHLkHgRlXuiZ7WyiJEz9hexpM3LBJ0H9qsiyPBZ6HLX7RySAIfslZ83wLQ/rUT/NBWQk0UOT86CUhOYKcV1X3e+6JECu931tMcncLoCzCRsiK8/hGnudO2J1utklSmHRICOZWdFOSRk9Zvr3HN0K0kIDwwgwM6Kkq4/qX7BOAaLCcvA1CBnG2Ba6Yc4M2FqTi0zdgWIrizeaG7Qm1HgNyDmsAxAsqwoh/VwkAU7mKZl++A90ZauC1EVy+kOl8XQCzeztnqMqciQ8O5UZE3JCjkylyxLyy/21OASb0r7Yqe/TC5xC8sM3RnS9Agw9ZO/TtrgppTJdJBPkf1yUp+F20FzLxjreCiksoO424U2DolMYZMXMjBtqQLleJDSWZCZ84X/Ivn1asGIsjIeXBxy0+M0rdT+e9yWeonfwIjq7bZbmGgamopsfz5TtCNt4KTvie8W9k93MtfQLPpiXdKexnm62yswqD0FgxMZOs3z0isNsv9l/2fwOqRu5I4lEH+kFHYd52lcxv4DSlL2+WwRO1OMRXqVidGRjAZydOzXnfDVHEtPBELbdZEOgFG5v2EWela58gDooCGvk7WGK3xi60hL1sQo48AwobBv4pBJCAFtLn7QFCAwxJW6jKaDaltentRNefe5DgBt+QEJ+Nhfg7YtRAaCe4zHcCiLJZgbedRiwide6Mk/V1yEeHBtJ3/Pr0YTj2qNpHAHe2umsBvXd8t9zO8CQnMZ7E7/5ljpvqw4j+5fjhMbtn68RVAAApjr7Nw0hPcymP5+03600G+6MQCplUkHg8s03PRRQTB4iRujZcjPRhs9+J8anv+xvJqm0Q5pXYUQbjpQQzxBsP2aFB5wEu0cBymNpFVKW084pV6J1udC9JBXFm5ONeeXkZvp0uuvaoZttLjkd6AYtZcOU9/rvt2+jhydYyS9RZYiIDyWg+WhRbBRJNtLRn/TE146+dPnQON5KD5ChVEzGfrjDOEjERpk062AvtDI0CVZVc2qsbRBXzwUeLKIRVAHvYE05irGCpD3ic+B+drfIzisd9N38B/ZEo+ZpuMp9FN6rAUZh7H9+D5q8Nvde6PcyZWsY7Cfhvw4pBDAaQjpuaeMi8HW4YhqLlE3j3yC/JAHuQ4fz+e1D//a5Hnv+TwOfTZelk9MmdEE68iZqzEUcHog50AnoI9u7MivlpE1p8S9W0tIdqJS+fXjtj5fpR37g+2rhs3B0/oyI4dcNPsTj6u0k3Jy5VwsiWfzyz1bEpzLT4YG9w6+rRnVQXNggYC3GFs2gx5axvGfH6YgLcu5v2B5SrOAGEqJ+T6FhqnRpZ/0xr8365Ojea9x5do5nFaB2vgDsl7KarWcSpyT4NKX0QwEcPhXYpZls4QotKrRScJnYY+86SB7a0GlCw2jqEu9TyI6C36NS9tmlUXzlAvof1uvB7FIJ5UcUTUJgTDm8CuETyxad+9PwQVDgcck1xgGaTaE09uxbdNfhJTpqqQ1DgKtRfSj4y9R4nCnAqphXbLsHT5y7ptKeFr9GiH2CGb4HTE2TNBWOYqn3qLlguGFIDq1Q4s4DxKX5I7Nf1ciVEdDTEK484hCHryyLnruQ6VQkEzrxdwWdRRNVZgEj+/1yQAhR2Kp46+vV0HvSjeABigWdPCnrDVvGBojjIa5bSrVnwLs90d+8I7raO2w2/DOnB06WvYrFG4QVb2QwIV/aNnB4mlqXk1dzCvGz2gch32Hy0dtvMDTD031PP1SQ1+L+Sq1q0s5/BNHiA39V9HBw9zMMD24JNA2n1DZFiUtM61WZiqDH2cTmKRSapIfbPjt9elPbpGy29AgCH/zS2+si5r64+qlqQr+qH/7ZRc28qk6ZjTO/vEuUVXAxr/mzJNGpvdq8f9ZJKLLk6SCAQoykCOAH2pUF3+CmcFy9+WB1JaV0adbgOB5BUJ7RloE9IvE8Xz+OSuYWtrAY3lADU2I4GAozCEwtcY02DL6vv9gGuZlMAXOgZtZAVBFwZJExok66uV+PqKr1eQ7DX+ENrxQWKpvGfmByz6se9L6v7rkuNLnk4B2uKpP7WHHxN2U45pTlUq+wqPVgGNIS5QA1SEQ5mWjrP0zkbxJ1C20lR+FlAD0yRjlH/uQXOudHpV/0zTZzHSJDECoFgsUGa3GpdXuYDPlKClSrcJi5nVhau6a2M8XGfOlv0JfYTPtaLVU2fCRa7oqBcx0NTnZTrj+t/IG0hriIreWeKGZDrvquWu6kYzkhJ6UlukXANVbRttwh9+OXybExTFMdRZY5R4iDuQiZkNfXap3zc4WDyVIHXEsWmd8Jz/pFJ05mki3K4OTl/+JZNZs2Vgrr4s4LmLteoLjntJCR5WinpAw5JbuYB9JQjQ8Upe1XzF1F7h2k9ZkW4aEZMG+Ml5horPBcgFn6ADjNQKzB8lqWM1gf093AnZvS+AzVpmqv1BemZ6sf9MckJ/TwvnsGiwOeJGZpMEXo0286vdFfzuzzsG4H2JBxA/vGUsmArbqd2fzI3Yi7YnMLFvbk90f15fs/yK86OoSVIylHY/MTw9j+OJLsSOkgNBt1CzN7a4yWi/ptxtK26RabDtr7W7NIN0YeWyEHTn/6mDQ/oWLiSCznqnJvVi/UmpmJw/9sHpWArQRhFGY7TaOYDf5t+2xm2iyG/tL9tsKBnE3lKnctPvJaoHdpL5vYl93SBLloyW07FnPd7/2Wl3BEe0ilHH2xNaqc/c2XMKK2WlpQNq3HFvouYfwGYmFdxF0VgKA6sAOBiPaXjMGYW9WN6fKBaqMjq/5CyxfHJtCjLpQnx/XZr7gVuHeGBe80OIYM2VN9sgx3fSV2YfD6ZrmGVlJ+f0OGUCAIjBo1fOPujyimKX1TmWdM9q93aAqFwxDi2PFOkE0ZD/GgUXGgbYHRx5hr3fCVK9Ax/+mW0QbIiSP4gne1mFny0krrm7E60VgipR3CRMNtYusLGgYQJtJS1Feae/jdJL2uf4ap+Sc7S39AUM0JCen6gYNzL5gPtJ0KfFrRXSFno44Y95EUjb67iw61s5ZhDUabTun6CbnFWdbGl2ejv3X/KrQCmUA9Wspx1h2Y214aUD7b5s6dQ4VSvBCXhOgFX3wsharO7KwPILX765+U8oFN0FzPk1QS3vGaGpt4fieace8MeOTea3PEVtT+sIIxzCxzD3eSOL0kX8Uwuk8ijp5pR2uhxo60d2HLlTPNP8sZPvr+cVtszOIdtRmi7CnmxI8NkEbY37xmhqZnRHz97XbfHgClQESj9jHqSsZ5ulm8vLFi30eIEcdH4EBlmO7MFA/S7o0TQv1VmTiokVdlVm48+DwwrVnL5Wk1dCV0bB1N3N5PbMkuX1jK03lBCCZtp76iKvqFGpXsyoOFFhw0wMBw0rA+tUQLK0BNvdXnS9ukvIUSwEOUuEz2bY0yO0lUOnkzCAjrv+WYJQOgWNe5cfKxBZ18oUspheRf4s0PoVbO+z8EYX4wzkEGwmZ/mEzLJMm4dVSTH8KByLANZzA3eEzEsHT0lyPH3uFU9/wBWjr09BsKgZ77kZPiAAL+89Qv+ZKG5cZOOhZryJC7GOLFC9fFF6uYHtPmMo6dA08FsouLOQDwAZpy5Du9IjdfavB65bMLJyEpTlOXGj8CdB+XACh8hDfcGLveekOKkKat7PjN8UdFNCFwgw8ZxuvsWMDXBQ9Os6ttl1n6mO2llGPi0NhyG03Zny/VwsRB6dfi17La1YH2D3jjlYTErekgV5ySZsRQc+Y7jgMBJ+ZTLd7lBbT4w94BILwvQAaazu9Wi0o9FdR1LogvJZc58ugZvJMYS3MKUQDq83JXC586ymjvyz69eu/E4/Ar54UX0kzcmrv2p2aavi5L1U/IygaVXyiMa7jKmHlRYilqFFHZP2rxvQrdbDksYjvjf+6yd1YImKADz1z6Q1sbaxhP7i2mUsxz+mGiqgEELr5jaIw25C8IZR1aroMAUnQ3mVKUrlmXCLu0eNkpOl7Uu4ORbFS83RUFfOZJAFKttCO2Yoszcy5KArYC+yqJGDjs8D4pxCXQtiiNn36PbxYA5NX2+hLR/ql4bo4jUM0CQ/wwyrtBPUpnao/weSDzhErxnoP6+eC3a0RdFa4olDxdlsdz0PTimcDfhCTugXYZwii61BvFAZ69oBymp9A2UxAksFKkkR9u1aAtwORLkBitDmzRV3zfThG9GlhzAEvZWjD4PDZ1+lWc9eqa5olJqUQi6vWMsmJfv/yL63tRrhznY5WwkEj8kgMNMqjitzQycPUcaSzz66YaTPavGLFyR0Z6NMsJyhaR+r1l6znvdAegPhrlPL6cqUGUxCO9OaOJFfyJnbDyzvIu9ONs7On1sJzE1LAbSwdzvaIj6nzpi61CYurd7jsBavvkYSnDK2gNwcZKEjLqyvdUWlFZsZ+zW7ld0SZzknvEG1AqKhgHklaYkmvlDKL6mXSs+Cxgb5jAvKk5ujNWLBwAtoJFtCmrZyEaxWSFVmMRyTHYYA+68nbH+o3HsIsHFFThXDvnEuE1tk9wdasJgGhZdo4qhwGt/RvTM2MeFVPKF4zHFjzOAbii66QvQQSMeo/9k5Wcnv1xgDMtD+TIGvjZRcAkk7Fw/IVNlYR+BvyqohszbWvXNHMRfH9apygjrBYgY46lAVYYBlBDp4ijSNI9Y0NLcrC+MhhoO3gW4i29qdzodbM9dpCN8+QdXr7RT8EzExAn7xR23fSZpmlFse501dHpT2rCUaNcKg8kjtRm9l9yx8p3DAe4HxEmVa4utv1WykG3ilIF2bEiOV2U7lZ8RfY2ixXyand39bnLKOXCgdghEGfS/37EgUs6MQfg/F79pnn7r2cWjaA/YcLwKoqUHg86Mn/8D0ouo557dKRMhW0KVa7uEP6AIhKXhvri6PM/xCNgqneDx65HjZwGrzYVkIC3qr/BlNnm0tswdkbVf4hLH901KDDdUw9LrdIpXmZxJOd3jAw2oIB2HjJgDhFqLtFsg55XcP2GfliNpbZiK9R5jfUTdl8sIZAcaIbdJJryIQP/e/5PJGFlA5Ze5HTYiMFua30rBO1H6v6uh82LDgm3N/LKUiHF0p5z/Xhp/58LSmV4av6asGy54dSF7FCl6W2SERnWpnKzbMDmEFpz7T7s7LI2rES/y9IegvcfQCg5HBYEPix6n0bnM2tWa4EAg2tDQ2of6TfJzPso+agdVcxYyW7q2WhfTMEucxcxlewDu7CNvaYvinK/9CbOKUunWxdaZBcMprPe+5oLsEZe+sx8pnJZQPp/uSNsHd9BuP2SAyxeY7Xtf9nBJy/j12s9x7PRWKcEscYFblUTNuwaVnfLQHyGz8npMGNaqn7zbhegfOp2jFHh8cRbuJNpeCiTk261ZZis/XG+KTfjjFZ25ikv6ORj6TwZ1hbtREIvb9TVIfCXKtJpf9rsj2W+Es3ZZYhvQ5rY91ffLj6K90WGwVsuq4byhE7bSakAiRjagdVaXb7e6hCDnzCNDSX3MnGF9Q4UdDLAIKbKPBManSrXLrqLBS7PyeiIQ9rvM3nBc4urNCBolxO9uXZJKypAJj883qwwYoEzaDtNq5WX9ZMnoIR7dKpjqXYYtHf336tAH8GwQRBCzboEXsa2dwBnWxMXmqbi6OZsYEFU2rol5ScogGIWDH6bphPYMYv6tIZcaRRt+Yf4jcqYEtB9EYgURpDrgTDof74+QFvzToq+k+VmeVO9CD+ARFMGTeYh7sXpm177T64vM6FQ429b0ESPkKVJ1Ktcu6+WBF/TqkUNozFN3WxIkUKU3zo0JOCE668uYrtMphy+OunOj6Bg8yJYsVyu+E2sInI4mnoU0eoRaE469kODxxd3KdRaZy5ZMoe3OeQj8LFYSIpFBOexkdyo+4bmRS96R2UEos1y56/5dlmiXPoIf+2g5ZcepzA4vpEqIGZJdaw++n6IafySzfjSJ2FAiAt2ufS+aakTNWUBFq+uUuFjI4fmxN6v6FNVuUNoCx0VLiqFnVw9bDk1DpAlwYIY7LIeY8d5rNp16++s0nNPsscI1GGHaUJzZc3i5VP6fxMwcZ3B3AwtyY9FX7IDdMuZrJ+MGKtmX3uEbrCYYE1bCnAtF0ms4ZwnrrVbGIFr+CgU3kM0zFzYMGzY8vePB1J3JsEi8eiHxJ+d5+yxdwnf0v87pA5igN47DoRP4xnKEVi+YyqwhaKOpJb/ToUeFEknZGmP6DwDa0PcBZV45VtDp+I2OFFJ6/ZkRCdp++BGlbtk13JOSr6lq6oYu59YUI3UDVUITt6V7osz4h/ULxZ4fl9YzUJ0VI9iQ/6B7t+RQYd2YqUtYC/NcejLLUoFDM0XzFnC0qnhan38YKOGb5k4y5PJ5/ByeaxGpHpvWzDmAFf9dt3se5yIDoNZzl1T/bce1AEGFNjrgu36PMvzS4UhToX29JzGt7LJ4DMfdCNp9Q+Q43VWq9UAui/Y5ZBV3ATc/ZfeLiJLxQwVhPoFqABMhajGtgTQkXZMdvPJ4Zyt91qmV4dty1Lqb3TtonHl1AAWbo5eMZo3Y8E37m3kCd0BqNvsHz13RyzSkBgYXOJNxap1F4dhUIsLiOesNxTynKab2wyJsNOPrC6o2ka9etWyQJiVeP84j+7l7ViW3H7/SvLD1/NllPoCK1z5ku4h5d8ptX3XIT8jGsfwLSiaNjKhXoN2Bf7vIbi/3DVeV4ohhSAwvNanJjYtP/0GaQPBLMbJSbze0+gaTJh8MdKq8RRWjJo54lK9r4YNfCvYqs8gEGD2C7N+4ajUpo9QV2A2ecJLY1aEOr1FrWyYUIOTASzXwlo+k3s2dgi+dxWwSTGD2fqUOb6r9oxj2XU5Xv6LH2n4pg08RAFPHyObujmeOAqptbf7ssjUIvOc+oAzubbOYrKBpsEqiBrFBprOYZ5v8uSP/UWNGeqzEYMuED8APc+jSB6kVLKx+daK8sAgOoSsLsU9K3wJ5MfUXw3GLnTUpV/02ykfjp4DFEw9puuAVDqrsKq5E97v1auUONI4A5NwSfTVnxPYLcRkqNICkTgNfb9wXbCkTgYXKTPj3x3vTnHVOhKkxe2SYx6zRDyU6M2QJMOHNG1mcYuLf6H4vUVdAy3bUr0eHeeSDMlMQr7lOqFhTW0r1dDAuGf2B2fhOTYDNoNhc0H5HgE8a6ijwAz1FhFCKIOkMGUER/jwfs0pKlmtbDioWtooZyeI5Gpz8pENHsjN7hYNb+vi2Wo5CfgEvA/ddoRUWWYGrJoj2XehWuTNmBHB6TUVLnuXLXJydT2GUhKteHXAgRMv1tqkNMe424oelbC3LZiIz8WeZ42r+OxG1rKTULjeMzb3DXHaYrnOBIj2Ab03tr5tg3df9PT+2mfi3fgGj3Y+WCmMzU5HfkwSp85dmNjQNdEIui6M4IJNpBYylIRvBkRrOEkcdBfRm/fg8sl1t5ZHPpVIbTV1MLfDtj1Aac6rcysCh9NCDhTA3GGUeRs7lu0HJOdgOrMkk1cWoWNvsQvmdj8X1N9RwP3/MU3zRTKmUlh/Vs9CnVNwSi2xjf7UXkZYWs1UsbtitpmjtwnCHJlm6BRHtM22qRtxoHJorWGYL57vE9DTxxAVPpLpge7IBFZ7n6sRF7i1Zi+HBoOolwA2ABTv9DgGaaVgKS8XvNZzjsX6mDmPkChLWtOEZNC5Do0H7D+pV4ybAo9f1j0eTLlcAuPrYBv+NnJriK6kyFI4Z7oohSpQTFdsNZO+b9PjcWzlSRKQVeHnSv2bOPcnQB2lz+UoyPeSYmD+1GMNHbePM0DmBbsQzedIec5yy2Y3Bk+0BVY9X1PyFQ5KQea5I0K2pfgEToIPaNbmUH5jiKV89M9ZOveLVEzMk70GryVBUwLkX8iY1Pu1Pv4VmnyJM5c5ENvSg8fbugPrgaWfd7k99yOBoqsjCK11r8MER/utUzr83TdvikQziwCHTOs3alhZVySIV2OJEG5wY82t/sOwe63Sh6xipTKxXGNYWjAdCTjs52DOKEpeA24eA62LOBmJOad/CYhXyKOEJp+1VXe3bdWEneDP7pH/wq8Qb1KkHJQnRhufJVBZRyHhP75KtTX0HTKM//tYzPcjD8jRbMzDhK65Si4o5x4ZMzaBaFWdJqKEomY0DfrFZtbwUjF9cQFtgPDPxt8XlZGXi3HSObsoRdSdCf49Ce9Jxozqstgy2MdkD2nsbck8KLUgk6GFJFhIADOBbaC/M2iT+s+rxeDD/oytExFrbFjGsa9YQdUAMn2knZneMUmNkRbczxstZaIMRHosiJ1YXF0+nhKbd0wLhki2sPX2fpRb1VLss+j73fvJQRatpa3e/UZv/0aUwLW3rgViyb5aNGk9dsEekzFhwWulFWaWkl3ZJW+6p18pINbK2OhCXRf3RmkeKoK3+k6ZfRvDQKGUOKB/9ee2DVuQw0vA+Pb45NiBC6Dh0N96gAQ1tqjTDGcHjZOZF3MvFsJSf8vxLYSTMgrk5IX3ft52gJU/Q6DRSKWp61CMzy4KukQT7EHbnRZmlxQ/9dKbmKnuUFm9dYatJYajII+S+cmP1tnPR8O7DSl9J/sjGqWSpkQ8cIgPqqD9cIXYZOIdA72HGvfZEw4GxSB808GFU5nWxHhAjeuDVRexGCipjG10cyEUljFiCUqb570yB3+TAzoytAFr8dz9Icm4fl1UqqXzU7VL8nSe2XljHEcRi4K8Ghx1ltKvtlOiGYnFnzEkrP6Z65zPIKoWQnfNJ6xiqbcABVzvPrf+96zAA4tvzW/eT7qGKKRkY6rsLYQR575Va8Xj37tgk+shG9t+4xzRXwh4gNcuiKdSeQz6dBzr4x3PGxYH27ElGyC2h6kRypQ2KdX0qllfswdUNDBDrHIMa07Q5YK6vJjEcrmjN6X4BOV8i9qdNNsCSQsUcDcUU06FganDZoxktHFcuuiBhDyYfwmY1LTpakRyMJ1ejKrqjJYmTLme1z81ea/q0hDDDi/RSohbQCsR6fGo/OdTHWob/wRYkvOX0lZRHF38vlF3B33dYb4SpvUCGOIoAAXO4Yj8ed4P/AxiTYqe5upqscRbqw/6q7KSVH8HKvwE3PXPsEau3kssrB22UzieqG4Rd7KEM0SG/+ud5DGGUq7KjVDjQaJat0hkC/kljACQKIO5MYEDGzQVD2HaBYy3NDYeHlX5cl3i813+fdtQrxSxpB8TWhS++yJgvcqPf4YpXtrIKxWzz93IDfuGB+8+wC/PQhfQBuix6tFv0hJAMCTToF8YrK/YrARjLxm6f+wMKxn3iA91yj+cbE/ygEAFe9ar+mqhxDOHMrCa4gwLoLWdDcd4RIfR7SNOCILBey7KjTbXVgFg3Ej/wYDJjh9bJcdqEO4EbiF9RNXvdq7QbBoPNI8vSd3wSK3Y3DYo/alJPetzVjPR6dgu1+rlvmmUKEwKe2nzZQj1G8bZTJRAuW2uiZ94GAaRgSO2L341w8NV9i6YKTebMoxHu80+n6elpYat6TeoN8Xa3yBA8eHiyMje1J4gZx1quFXOaBmzAhiNYavohhJ7K3J0/A0IqLYHxlVSG8j6T33bZ0USd/emWRFj9ESMaw8Zg1yIHtSepgYTOTynQDTy5Pa4U0ASH4pmirZwfP+habHS5Yam+v1r7a9eu+liv1Bp3b+DOcfFj7op/tW56nsLEKSeoljr31o4TUM4NiA56j4tFfvNSBVDS20b73jdxcZ4IBOqHh/U71F0xg7tWohJ3+LNw5DJKuwH37Ctsbp6iFMhJ8imrvne/cWtP6DAOwCciteCIFGtwZ9twFmiwdIwmLwZIsB5FZcPkh88AOZMk4ic5X0QFNp4jALzvm+0ADm9RKI6RFiqM+s0W5dgdrUZLbnusTpJhCL1eEi8zoezEB1oFqbx63o0Wu6E8LoshBmRkfxyVXt63Sky+as7xCmDv75U4uzfIAVckl70/Qs5sMvTIKvwt4GETl6I5NAz3ckpr9iBteK4F3cGotcDckZrH98al3+BOYFAaKVU5YIoygh8df0yp2EDPI3V84mblU+Lv/45wNQ/gEOvQeZrycR28KjdvCNY/NkqRhK4QUSR4ZGgJbhL/7E8rxHDSeCKwNSOUL91gAhnXJEDIB3NuzFIkTkWRMYZlboreX3MJMK3GFHYbPpflDhEBXAucpr3CwvBuo7lgnxucT7T52ldkzlXF8Zt8ByzAa3oSeNTLTBpD7OTpApCELqQ7CHPwRPQy26v8Z3jDRON9AX8e/ps7sY8p/cfn2qXvYLKICdNi/Wz+Dhk60UzvZzvS4t6lRb6DU4o9GbwANgwgASqXh0SzoeTr9s6HsLpn7zvA/yHQ6kNNd4cysCVmlITHGzbz0siU9zGc2f/8gdsj3cvr+P6GazXH48b+el2WPrmgeriA986WGLWOumTUi0CwZyR7pZ8d+Vo8msV9w7BVIcMnS74rO3lnBrHMDjmPyuoVEBK5YK+WtOPHrxf6amWzw0aN9s/sUiGzs17Errf0dM8uYJOoY2MzB8yABZNEVuA+/VwieLxopuvFIHxYTeIV2VJgYPrAOgt6UrEBTrMcl/R9NyuPZ3FoW3Xh/p7Ly0XAOQPOc02g5VDiJAG+3qDznAtmtANEXFbJJbsTXmuL4QCKZEElYlhPzvHd6fzeGnYWOlV3qzgicr0yNliQ+D7PXVd1Rz+kyCUdiVqkrdkxkvtU3itYh9ddthJHOrIj0Cnrm5zvwIYhIk40HtxSl9JLiJwUtM+CxBNhjC39x3iUiyMliBIAsYY/tJY+VUIINwPrhb/loM5YwAWwyFY6j3fjEzgZBFEJaDasJ70qY1SW9ZWmp3ygYmmg2eITetEJ2E+rX0S/6TGzEGDol1UUnDIvI376e4rTDKflGwV6RGqQRA6Q7yVGLHzpJd5vdeua1ffckGIRx5cs/9S+YRfqw05kPB9enW+wi7LjA+EerH3LikFibQYTTCmlZrZ1h3pyA1GTM/LprJhELwi/QlAQjFwmlIXp1yXgkp97l8/MdXiXDOHA9ouE1ZlhkOj3dTavw0K4Nqg9QL4EcuTTJysvrdERx5qgHUFMLNRAbbNkRUSC5wdA3+UKgKirnSwxo7sF5rxxglE+GojcWaq9Xl2T1obvFQmn+5625UJOXeM8AJBj8gzBtaaM7WbxeyMKdYho1+wRR/M4JMX0YuCCut1MXPmEK2oUIgNR3H5/2MXVI+ZjWoDakDYAievd4OAAJv1um0y4xc1lLosVWp1xdUJHHi8jY42o9+Ul9y4OV8FIL+idK5YBVQAXy6ttlgQsBBccH6X0VEPm6DlF7DMu+ClxFy610liZfjhrOnC3qRCR5p0RfoHN5gfSPw3nSXwZZ0zvtsDIyQTNhoqNA7Nv+J02VXOG6wCRYYgUIE4xSgQU/OVLMZvKxnX0IpObuYdhpS9HdIIhvqz8kMxijOqSBRW5B2KLHakSsqBU7+YR3guH7SQJY8+qtnt+1m8tS1PmLHkDIRkutRffrfXfHjCAuDI8RmB1La3uuA1uMC2yqMjfqlNojZM/c7HD4uAFD0Wg48bTZ+6eD2BdfKrNc+5GXIIyH09X0dtLR37BoIudaAVIEOdsLe5b/tiwlkEQuJ3DPLQFxeQoGXfOY/4+HpMUNKy+rno3jvFIglwDxR9xhgAxN8iEvFx0MD7+LG3xKaAYhAUUsP01iUg4X8L5sTt432pEv9dAFwIjh0vjEfdD62YO09xWReLjo5Nn6JxZRbk4XDDTDTl5tJ8FKMv/BMebIibMAmcVPiMbbQZud+BBON1Rafi+h2zGhw27DFJVDy3KKgJpk06RPdv1+fl/Z1kCFb1GjrvXaFiFQaL1SRUnfLvROAqA/fKfUnOfJ5ImtKFhoE0Wws/vMs/rMwWgcWPcHfcWZdbgZQ6Hwpbu6tfEXDlDNu4Cvh0to9FYiNrcwUdWgD3+HDJ77kHAQOzg3HMkCBHAACR8YiBTXujniph1ABfGZb3gvfYw4fWYHFaNbu1CiIPJUp9eeA9T6z3E/FLWqqCyYnQ1ROaTBzcFyeIhds1x+MJI/scW6AcLN1jjkjPY7r++RZBsKgZ82nApmBEsfyiUsGUqU2rG1s88PsQ4sYW/E/n0IPGF07wMbrGDspKkVU1DqfNIYhwb9xjfxXMqGTZ7AmZef2I4V0PB7Jhr1VVuii69zmGT+W5G2G7schVfMlBIu0/TaoGo5QJTXbbdjwlgzqb2q6tUSYlMQ9zNp3IbJxwnqAlSisZyWdzKZpTHsDx1G50xpOpfiZkWq/ZYQ2TJ7QeS+GHDp2zvWgu5oFu3xnpia1vkWujvIyEISgieaF2pRwC18UdMH+cZjaWkO0500IPbffa5k4ZkGZIFKo8ZXg0Xq69NEhHGUEBV3d6pVsOhHrvBV7ZNEnA4PtP3Du2VDPFOydOEcRgbBNlkBU0nkyiVLJyM4uWdMpGxck8KPLn9G1wYe8d1cwa/7JHtIikeqVnN9ljywID9SVbv43LFWdNXA96YOVCG51zwxBX0+CvHj+oxqYcanNN8WiDVCJdBLKr1qjz9iqRoWwEXJ9gUaZXsqIy0wty6BXLgg+Z2ufmgGDChyw1zeM4Y/sr05gXmDLoRZ7/4m3SjgwO/kuWSh49gSyaUyTa2KRkELgcgkWcsIs9Oji+BMDO1a/TK5N/qXW5WunrXxca+gGI6aDyrGdvblVDb+jvkfbTetSbjUEqw+Mx9/0jtb6QA+zR9/sADFJJHXd8sIa/0HFEekZnT4MKujRPtKPfKN0i43WeiZEMlCP0GYYkF/aO7bxMhHr5rAG8AzI08XYSJgGlyRIw253rHMR6xeBzmMkc5X+4nVPZgUsMKYU2+CQzbs9yru2oqbNtBxUb2jC5+iNH9+CIwHeJvPeP/sX+440OkEASJ3JGZQQ1rK8F2x1YqfDQ0IN0TUFHV1jXbLadXKzMrs53wPJsbbua2sVl9L3bcSxsdfCAG2+fPX0wA9E3oasd/VlNSv918Qhba5J0XGBzVpSkWxpH0r/qkyId3EbNTWeO19r+kxzFfC5N7bASNMfmgFQv8S5q7kaOMAh0Au+YRRNPVXn4W8nADRJWjevBU2pgAV+dr/fY92A+3tvDawjjXfAMktTQtML7iziktOnNpOZKkfFK18l+UbzM8nlsjHzCMHp7DTyVemmTYPa/DnbUq71nRnG+JHzq1lZ1Wesp2Y/NIJHB3pMxPRX1uZVsAgCnwsLrCA8RAEx6u8TfgA7rzF/z28vFTy35g6fpGAf/dIHibIyL6BaTtDuqcmtr/YG/QQxRMEHcftdhUePyscv66RHLfHPeqPK0k5DMx8OagEiwxAoPWls305xekXIPtGv5NjfTjh2UBIC9qAtmoK2fcXLghhUrf6apomVnky76og/tGS2zXmqSgyIYJ3xSaTq3mzBjZjG3Em99egv9vFgUeTM9Kz6z5SXOOFSgTi0gy3ZmEkU/W/TpxkyVN+qZ5eW48iW/tE2+rygGbt04llcdmWj/vmeoIK425/n+9nt+wtPxXrKQO1uT4vXWOsmOsRODTmKqepPahdIPb7Y4orkJ/oTfiz+KWQA3o54WTI4jgoBbaiseXwZRengfwGjSk08m/o22gbkshrO04ctQHArBM2IweU31klUdKJmILUb2jNIaQE32guicNrbE3IztVQmB2aJSBk81LITQm9p92MDFDOJ9Y5ehV3Uv4dBxYoLZuOOlXqMEzzbLrl6HtN89iYvRCVIRcCPgTvMdsr5H6dxrU/OSf3m640b3gnhFApDTaYeCiIutqVaW6nNvpSFOOpXZud0xcNnYcZ5YovRMN7t+8XlPHXugIilYR02qBqpoEiQ0U9oV4ip0qZIvSaEk698p35R1p+qF8Ob1XNvRLdgr2qq9t09TyBWBAEjwSGnTD8UeHxpmYs+RdNuptsAI6YDYPb/Aie2Gw0GdE9Cgu1yFzudpAUPUAAAKZ16maTayaKDP1+eUarkUcjtLUZvNMbtfcJfnpb65maT4DTskUb/cvgVkNYcCQpi6ADcCAz6qXk+mTM25qJzr75WNpxsDjsa285UDNJRx6Mh5oF6EZhuJ0Y/T0Ll3J5yaN0ddwXkiUj4kBXnYnbL7/mwfezLQDoTUNhMuWIWrh18rPZTJmLJ6iyNFGT7sR94xjYynNtM5EJfT3zAPY7+FgJxKKSQRaSHsVYc1IsgxyielApWGLBwpJnIX8Je7e4YaJgb+WFcK8nXu2PMMP6MqxDma/1eXPHfFuhRa8GrUYPFjeYupyAGunvQTM9pNpz4mHdaIXrVu2itMqmsCgwaiEg1gBGdf0Z4npz50hBSRYb+wJXvvILr+WxkesFBcCxXbQH9WvaFX7ebtlmFo4xXSV0S6ZWW9Ajo6l3LkDgXFnHun0d2uKwbv6EJasksvZj1l/6uYn+pLTnBG/SOhMkFJ3kC8fydlAzY0ETXvNztyHtp7e4zbpOwEyMGFEzzJx1WWflqDo3uzGStJ6SvgJTKcbT1b0A5Yb74iz0NmCX18degdbAQt1p1PAZB7W8H2shTenjt6YnDPGjtKzAWYjWYp/s/Jn8hvKflEyR93x3nYLuMAnZoqyzGwEUMK3g13rFXyC/MBAMVZEpPN3WmyWGfj8by/9UPtKliCIbvDMOp0Hfy0jQdWbkBK8nfJfhkdTo8Rnpote8L1caRGxq7GzFOSJKeHCPK69N/hwLLtCo8h6JkNlNW8o1DUblcSSLqXYzvOuWIniHuar5Y4d49tuKzRQB59BPzB7RVteLB87W8F0f7bCBvEnjEO4pmzPI/CnV2h1Nt/cmYGIqbsyr5XYqkZbA9sAdTOggpunoGNdILnHMpbl4uNqtTnkFQpgzawawQiVhUAJA+JP4hFzzUoat+8QThqmdnyqV8wHwq4HRsYe1iPiyrBcn74X5LZMVeTFYG6mQyuDypMuiWaCEKYP4g9J7ltezKShUnmZ10hWYhAiqK4LfVkcntLqc6F+ftbxbaiQsRLzoNyfo88w7WuzjdNiPFgx3a4jydg09CG5+hNII/G88AlB2dbh3fTwSjSziqpeegCH8pBEj41ZY6BIuEbetEMiQnnjxJ0VLJwsSeI+KD5X0BSr8t2EvubgC+8jFUvsshv9DCCMCr1owiTYn1oIEfFQcaBFjx3yxY6Z8dO6B1zD6HKzyQokOKKQysTvU08yQHlLmqFjHiD9bKn0icVpJTOAZhzR07qHLYm+BcViEwAMvXLq9GTIEwyqqGpBa9XYzP+Fi4PlbUCDLqUPmcGfQ2YSw5R+2frLSgJ8fBcDv3S38j2xXtjoukFCcvz7yP3Xhg2Vwgb1DpWypukViqgosBTi84VgtX6J6hw4eIUiQlAJOAAAAptox8d3l0MFjm74C6YZYcGS4n0gMmsqFnJv0Wja9P9iFfJuDmhxvU0msyZB1rOyyR5DZHXPu+ESKTDsNE5p3fa5fDKSCkV+dq2gL8mLwG0KGy9CXeVYF5TOlJV2GeTbFuPWyKQarfPB3yZgMz4tUEmugpBlCxHXwsP6Y9mzKoNBmNofbX73p9J3fn75aECgBStv/gw3tVcqKSseznYtm9V75h8L/+X3iFMX16WOhljbzer0qZq8ADl2/los9tYL5kWYgo2kFrEuRQJZWpARjSxtgmF9GtSjHBXQMqU4kr7fF4ESpoirkVPex1fPU5OEZ4DH2bpVuwy/dGbeYXNzDNOhuPg3l62wgYkvNDIA/Hkj+VcN0G4PJ7L8Wfls2rFAfGUTU7Dbq98QfzVYe3RjXnbHWHn41dYXYCPdtVjBQz2R6tKdST+6k373vyAujy4DrPCf0Q1DG+YGj6DCkhdulyD8HWhgNlp5Ilnrx0GMB+gPYWZ/1Uk+UwqRiX6Y5A5fD9ticQAKKKpZy9f/ZoTFKcpx3B8eKudRaBZevY+fHS6JxSPbQSbKJEJnwCIzIIpVN1MW2Bd1/FBwPdi7+2KP3/USzHX03M663KAYrAPUAYU4z8DA7RHKLVwUn60J0s1mijq4zpaTl15k3EVk9cnE72Txz/lBma7MQbo1+AUJZfGjNLCcOwFsrwjHgCZBud1Mz4KMDEWBd2zgfKvcoL3l9McfxGQpS8JjKhDv8VLHN9mEC7bdwzGqs9RDGFGuQpcRDznHPMm2Cfaa5l7gfXJY4GIbLp2zgVmej4xEDWNnFX12pQZ+crnc8rxZ7xNJajb5wAsugSKr5A9Kn4R5LZHy3ALaXCOaPzbrbCaoaCc5MBXEvcJaxX0fMd/qIooZADluHFWdREme/tSTpewhJB131v0TxhSiGHmZlmy5TAcNyABib5tnwvOZgkEAhg+bQxr4zUZDRPRFX8OIH696zCHBvuu20IaHAAVUnThdWiyBU6OBiQYXhLHOhXErZkL7KQdFsVLzdFQgyG2zDlfhSIMr7DFcYJ42ERNNjNNv8IXtYASim7UkqF0jdDpCMRvp4P/0g6t0CXLm2J0Vzr5Xkf9nH8NNtoxpA4tpXFVbuBqn1Bp6OVITBdilMXVZFpPe6pGLbXaGwaHMFg7EK2Ht/nzXGjIyAD8LuYlbRXYlPTA+2YgPmXMdjw086aZUEdfLPTfdbu0PDyYU8vTPZXFu0k2Y1PadT86nThBhmRDwoieQrWDf1D3BdLxmzzx+CoqII5xtVugTbs6mkaJf6H23q64mRpZTM6K+frKbtudV/oDDcSPv+9aj5203mvgLPlTVJKuzo/xrZeVqAlnop54Xv+M5uRCVzlJnwgyRtrDVKuYKTjmpTnQ4OJYB/FAAFWjq+/6UXexBsKcVW4siAmGWrU5YoR8K8C8DIv1sFC6eNF6JCqsK1DPKlL49Rcye2Li2GjysdZBIQvYsqzbLgKa5yMI0GhJ41OypgQ7FhCiar7q1gfHf4djp3v+8dMghkHEIxpufZhPlztT8URcOIdH5VXuqvuEPZjZUpV6yMACXx/k/nCzgAV6e2X7BSmMLk1Q9fAzaiN5xirkdXGANxcE4TRl7UHgD6Bt4K3Q7d7cxkN8ZjpgUNjJCK6xz9hv2Bj7DzS3AgIUaF+3FzfapKaH1A/WLevCiHEyslXcRJ5m7xFpW8D3ZlD3IDf9i/oZmCrrg0ZN79wKhq8cDZ4qUkvDO0MwwLSb5vcuEZIIQdFepWepHP322/x/8cmgjDCoKgRGLA3pCel3ITff/xIdL7iJhq+LoIEKzXIRhtZVzq5yfaCdl+R2UmYE7udBZziUfK3O/D46VkmWf9zKM0VsyrLlylLBDqkBN5uqwBaj0CgZBGJbM1ERcqNe1DvgCkVmn74FOHS2VUN8FpyRoEq4qbXribRWLqjAxfOwTDFJlChzDzq1gC39TeKPNdHwPSKTv0KMGYJ3ukw5mMdqNCQOpY5Qd9uHxAcN9GzRTOq8JAuBsEA73VV00+O5ZbQGlBu6X5Ppc78njJqEC5ItQlDB+S8ckyML/NZ0oDT85o+1n5EwvNqiLN+rAZ7k7+o2lcAaPaYX6ujBSG5PMSKUxkZWR4+rsYO7ihhaNrtt3AlFV/Adb7DgMkEQGlIa5xKvPLb8Zk1b6wINrKKr0SR9rUHuw25cM5Jt7NWPuhE+yBK9aw0XpLm345AS7bsK0oJ2pg39I/YlT6bMw9at9AjBnSSeXbxtGzEa8NO1ZCiXouWo8brzXwaMeSHm2+q1SEaxK/Ifs3lcIK1+vHxfT9nT7VNHU38gvZ7gCkEtt4fk5qv7D8c6/TXZ8dZ1JEdfYDNDVUIxXiJAjYoEpy3dIaok/xCmIdP7bcYGUI5vlSdp6LPg2fybip+935kvf9NHD2BsqgYNRjY70HCBV8TSLmjNu20CSfwkiQe9z4zeB/tSSf2n5AmRjZYw+TOsf0gY4FZKIG7hrVdSMf0DTSGGEiHl2AjpWFpb74+rs9yVGYebiY2qLhuavIzF0LFG5/+RgYOOM6e63q4JwavvZrH7zDitZ7XflW0tmtXgn7cspLfw8Vrzz0YlZf+a/41+qhpWjePUgTNhvbwZJbk4gwDESBwwF22f/WYym2EcV5Hb7ARfA5Yvd1zlmG+Sp4eklDU/kufkr7ZK2Km5tpTBirZmAUzq89dZ6FKu/SRV1SJ2r+cv4EUuMgdKpURoE+OJpHViT8sZDma4R0MW6tSOkYxB+ChZbyY7oxpGc8mcLLhqBW31TfbgIcZulyP79wKZ4noxddU1p048YKWEZ6Gc2AALZjg6CgABPoKLI0SiA2ptfGf+/24Schv0uFWlmGSmywYq8WQqve54t+Uvm0eGxGLzewfaQDbVqTetn/imoqe30zKa9HfXuruLsenRGYxe6Yp4AJZfNVSxIbUReiJNom5M5rsCJQChaUcPjwoE7tJMq0JKcCE5HrAVRfPNaFzV9XaKELpXAWEyvHGXHKOxBLclt93VadF3/3RfhWJDSozLqlRuarC7pm9sJP7xdz1H2K14d0wIqqPqeJpVxz9P1tUUjHJlkGfsqJ7XjH5YI8CURSZKpQzwPoyjJ8fPXHkkjcUcJ3fdn3daY/QfyB8iA5L2YGT4zfXLpxD5B+fIB+kAAYgokm6BkPJPwpApBCQ0NMvAkthVz7fOBC4rxZqaZdoBaT1yLHoZ+SSkuc95cohE7e+afJc+PcM/QGzMwZsbsU1FjLTDK3rPIn3O5a5HenHmcPil+eYb3nLuD5VIzDAQhMBKiDc7ME+hhZR4DZ43fSXnAmUqErhyjg4S8StEz1IWviOlJHc28FN94fSoDJG3AZv42db4y+SMdO11F4TH1x+5rgXdyHSN36VV5sRGv/Y/N63uRrUEdLUG/27ATeKcxkJCFr1odXNA5tw1aZQH09RibUxx3ZYQB/XIpAw+Oi2/lWg4F31x50l7oc6hmaYvKqZqEMgk3c+2AgZvEAL6N8lylKr2z24ADwSedLZfuX+xgJy81YwFPbVaYj7Bg14n2GhLzb8UNpliGaEGOP9qRhMFgfp56bs6F2bVwGCRKgzOMXwU9hyeAc95eHChxC/HhFjou1ThM8nsEGB3tCexwdPUSsUC9RPvIncRhyaRkKvnSBceHdTbec0iciqmFVlUL+XQp/zUYsNBVA1ZZna2WeziZOkc3ypPkgngX+IaU38+pPf+6Qiyvr8h7wH18kTj1TwOlwSvzUp6gTS8jKEooXcWD5/Y6UFVwuHQF4O213+n7iSGfPYPQXo7Q1IheTDE2To6NNeJ/51SUTbdzOLx4NfjLr5SnZlKkjfMGzZ1bGxqq+3MRYiPjXDFpfhnY2E1hjxEUMB3H9IFhL22A7PRV/uT89JUoae8VPo/oKTtbuCWjuGBXTRAyeMtrAZdDnKE/B6Dxsn/1E4eQpo5FWWkbt+gIk+EtwYsufh29iAkpQM9vYfH6jc9DzjgABYgdBSmIHKro6ll+FU4v0DPAW42bJ+zeItF75smvbbZV73J0ZRFzyq8eGJgQTFz5WAzgIrYmcNsRrKOhCUYLh+Fq8YRJmnQZtWXumoSWTHvKDpYmHGpuKD6juFvv0ovCfo4WzMjCsiftiyHvKjjM3KHiv7t0Q4QkS9FxIqQqlA9I/xVF4gQWlk7Ert+1GAvFuqi0aY9UQFw9JkaXqOa1PvaEMzNwTHqQaFrbqhui7UWfAxA9N+9icoI3bcCZk6Dtkdnzbis8JsLfQT7S2tgENelVyw+fYrju4ws8ODH+U0+esuKG505aaeg7/QKmhQdQxmyp+JOPkpfQOhH5nEriiw4yV3xKvzEnhGhPUYzOIx/t75b/qFsdn9gEJFoSPwaEcY+lx8EN1upgfK2VhFYXnlgUoN1ueJ+h5mQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=)

##Filtrar al periodo v√°lido (2015 en adelante)

Dado que los registros meteorol√≥gicos presentaron cobertura a partir del a√±o 2015, el entrenamiento de los modelos predictivos se restringi√≥ al periodo 2015‚Äì2023, garantizando la disponibilidad completa y consistente de variables clim√°ticas y epidemiol√≥gicas.

##PASO 1 ‚Äî Filtrar al periodo v√°lido (2015 en adelante)
"""

df_model = df_model.filter(pl.col("ano") >= 2015)

"""**Verificar que ya no hay nulos clim√°ticos**"""

df_model.select([
    "temp_mean",
    "temp_max",
    "temp_min",
    "humedad_mean",
    "precipitacion_sum"
]).null_count()

"""##PASO 2 ‚Äî Crear el TARGET semanal (t + 1)"""

df_model = df_model.with_columns(
    pl.col("total_ira")
    .shift(-1)
    .over("distrito")
    .alias("target_ira_t1")
)

df_model = df_model.filter(pl.col("target_ira_t1").is_not_null())

"""##PASO 3 ‚Äî Crear los LAGS (memoria del distrito)"""

df_model = df_model.with_columns([
    pl.col("total_ira").shift(1).over("distrito").alias("ira_lag1"),
    pl.col("total_ira").shift(2).over("distrito").alias("ira_lag2"),
    pl.col("total_ira").shift(4).over("distrito").alias("ira_lag4"),
])

"""##PASO 4 ‚Äî Limpiar filas incompletas"""

df_model = df_model.drop_nulls()

df_model.shape
df_model.head()

"""##‚ñ∂Ô∏è PASO 5 ‚Äî Preparaci√≥n de datos para Machine Learning

**5.1 Seleccionar variables del modelo**

**Variables predictoras (X)**



1.   Clima:

*   temp_mean
*   temp_min
*   humedad_mean
*   precipitacion_sum

2.   Historial de IRA:

*   ira_lag1
*   ira_lag2
*   ira_lag4

3.   Espacial:

*   distrito

**Variable objetivo (y)**

*   target_ira_t1

**üîπ 5.2 Pasar de Polars a Pandas**
"""

import pandas as pd

df_ml = df_model.select([
    "distrito",
    "ano",
    "semana",
    "temp_mean",
    "temp_max",
    "temp_min",
    "humedad_mean",
    "precipitacion_sum",
    "ira_lag1",
    "ira_lag2",
    "ira_lag4",
    "target_ira_t1"
]).to_pandas()

df_ml.head()

"""**üîπ 5.3 Codificar la variable distrito**


Como distrito es categ√≥rica, la convertimos a variables dummy.
"""

df_ml = pd.get_dummies(
    df_ml,
    columns=["distrito"],
    drop_first=True
)

"""**üîπ 5.4 Separar variables X e y**"""

X = df_ml.drop(columns=["target_ira_t1"])
y = df_ml["target_ira_t1"]

"""**üîπ 5.5 Split temporal (CR√çTICO)**

NO usamos train_test_split aleatorio
Porque es una serie temporal.

Definimos un a√±o de corte

Ejemplo recomendado:

Train: 2015‚Äì2019

Test: 2020 en adelante
"""

split_year = 2019

train_idx = df_ml["ano"] <= split_year
test_idx  = df_ml["ano"] > split_year

X_train = X.loc[train_idx]
X_test  = X.loc[test_idx]

y_train = y.loc[train_idx]
y_test  = y.loc[test_idx]

X_train.shape, X_test.shape

"""**üîπ 5.6 Escalado para regresi√≥n lineal**"""

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()

X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled  = scaler.transform(X_test)

"""**‚ñ∂Ô∏è PASO 6 ‚Äî MODELO 1: Regresi√≥n Lineal M√∫ltiple (Baseline)**

Objetivo:
Construir un modelo interpretable que explique la relaci√≥n entre variables clim√°ticas + historial de IRA y la incidencia futura de IRA (t+1).
Este modelo sirve como referencia m√≠nima exigida por revisores.

**üîπ 6.1 Importar librer√≠as necesarias**
"""

from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
import numpy as np
import pandas as pd

"""**üîπ 6.2 Entrenar el modelo (con datos escalados)**"""

lr = LinearRegression()

lr.fit(X_train_scaled, y_train)

"""**üîπ 6.3 Realizar predicciones sobre el conjunto de prueba**"""

y_pred_lr = lr.predict(X_test_scaled)

"""**üîπ 6.4 Evaluar el desempe√±o del modelo**"""

r2_lr = r2_score(y_test, y_pred_lr)
rmse_lr = np.sqrt(mean_squared_error(y_test, y_pred_lr))
mae_lr = mean_absolute_error(y_test, y_pred_lr)

print("üìä Regresi√≥n Lineal M√∫ltiple (Baseline)")
print(f"R¬≤   : {r2_lr:.3f}")
print(f"RMSE : {rmse_lr:.3f}")
print(f"MAE  : {mae_lr:.3f}")

"""**üîπ 6.5 Interpretaci√≥n de coeficientes (MUY IMPORTANTE)**"""

coeficientes = pd.Series(
    lr.coef_,
    index=X_train.columns
).sort_values(ascending=False)

coeficientes.head(15)

"""üîπ 6.6 Ver intercepto"""

lr.intercept_

"""##‚ñ∂Ô∏è PASO 7 ‚Äî MODELO 2: Random Forest Regressor (MODELO PRINCIPAL)

**üî∏7.1 Importar librer√≠as**
"""

from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
import numpy as np
import pandas as pd

"""**üî∏7.2 Definir y entrenar el modelo**

Usamos los datos SIN escalar (Random Forest no lo necesita).
"""

rf = RandomForestRegressor(
    n_estimators=300,
    max_depth=12,
    min_samples_leaf=5,
    random_state=42,
    n_jobs=-1
)

rf.fit(X_train, y_train)

"""**Justificacion**

n_estimators=300: estabilidad del ensamble

max_depth=12: evita sobreajuste

min_samples_leaf=5: suaviza predicciones

random_state=42: reproducibilidad

**üî∏7.3 Predicci√≥n sobre el conjunto de prueba**
"""

y_pred_rf = rf.predict(X_test)

"""**üî∏7.4 Evaluaci√≥n del desempe√±o**"""

r2_rf = r2_score(y_test, y_pred_rf)
rmse_rf = np.sqrt(mean_squared_error(y_test, y_pred_rf))
mae_rf = mean_absolute_error(y_test, y_pred_rf)

print("üå≥ Random Forest Regressor")
print(f"R¬≤   : {r2_rf:.3f}")
print(f"RMSE : {rmse_rf:.3f}")
print(f"MAE  : {mae_rf:.3f}")

"""**R¬≤ mayor que la regresi√≥n lineal**

**RMSE y MAE menores**

Si esto ocurre ‚Üí justificaci√≥n emp√≠rica del uso de modelos no lineales.

**üî∏7.5 Importancia de variables (CLAVE PARA EL ART√çCULO)**
"""

importances = pd.Series(
    rf.feature_importances_,
    index=X.columns
).sort_values(ascending=False)

importances.head(15)

"""Aqu√≠ ver√°s:

ira_lag1, ira_lag2, ira_lag4 arriba

variables clim√°ticas subiendo posiciones

distritos con importancia moderada

Esto muestra c√≥mo el clima s√≠ aporta informaci√≥n, aunque no domine linealmente.

**üî∏7.6 Visualizaci√≥n simple de importancias**
"""

import matplotlib.pyplot as plt

importances.head(10).plot(kind="barh", figsize=(8,5))
plt.title("Importancia de variables ‚Äî Random Forest")
plt.gca().invert_yaxis()
plt.tight_layout()
plt.show()

"""##‚ñ∂Ô∏è PASO 8 ‚Äî MODELO 3: Gradient Boosting Regressor (Modelo Avanzado)

**üî∫ 8.1 Importar librer√≠as**
"""

from sklearn.ensemble import GradientBoostingRegressor
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
import numpy as np

"""**üî∫8.2 Definir y entrenar el modelo**"""

gbr = GradientBoostingRegressor(
    n_estimators=300,
    learning_rate=0.05,
    max_depth=3,
    subsample=0.8,
    random_state=42
)

gbr.fit(X_train, y_train)

"""**Justificaci√≥n de hiperpar√°metros**

n_estimators=300 ‚Üí suficiente capacidad predictiva

learning_rate=0.05 ‚Üí aprendizaje gradual (reduce sobreajuste)

max_depth=3 ‚Üí √°rboles poco profundos, generalizaci√≥n

subsample=0.8 ‚Üí regularizaci√≥n adicional

random_state=42 ‚Üí reproducibilidad

**üî∫ 8.3 Predicci√≥n sobre el conjunto de prueba**
"""

y_pred_gbr = gbr.predict(X_test)

"""**üî∫8.4 Evaluaci√≥n del desempe√±o**"""

r2_gbr = r2_score(y_test, y_pred_gbr)
rmse_gbr = np.sqrt(mean_squared_error(y_test, y_pred_gbr))
mae_gbr = mean_absolute_error(y_test, y_pred_gbr)

print("üîµ Gradient Boosting Regressor")
print(f"R¬≤   : {r2_gbr:.3f}")
print(f"RMSE : {rmse_gbr:.3f}")
print(f"MAE  : {mae_gbr:.3f}")

"""**Qu√© comparar:**

vs Regresi√≥n Lineal ‚Üí deber√≠a mejorar claramente

vs Random Forest ‚Üí puede ser similar o ligeramente mejor

**üî∫8.5 Importancia de variables**
"""

import pandas as pd

importances_gbr = pd.Series(
    gbr.feature_importances_,
    index=X.columns
).sort_values(ascending=False)

importances_gbr.head(15)

"""**Aqu√≠ se ve:**

lags como predictores dominantes

clima con mayor peso que en la regresi√≥n lineal

distritos con efecto moderado

##‚ñ∂Ô∏è PASO 9 ‚Äî Comparaci√≥n formal de modelos y selecci√≥n final

**Objetivo:**
Comparar el desempe√±o predictivo de los tres modelos entrenados y seleccionar el modelo final que ser√° utilizado para la predicci√≥n semanal y la agregaci√≥n mensual operativa.

**‚úÖ9.1 Construir la tabla comparativa de m√©tricas**
"""

import pandas as pd

resultados = pd.DataFrame({
    "Modelo": [
        "Regresi√≥n Lineal (Baseline)",
        "Random Forest Regressor",
        "Gradient Boosting Regressor"
    ],
    "R2": [
        r2_lr,
        r2_rf,
        r2_gbr
    ],
    "RMSE": [
        rmse_lr,
        rmse_rf,
        rmse_gbr
    ],
    "MAE": [
        mae_lr,
        mae_rf,
        mae_gbr
    ]
})

resultados

"""‚úÖ**9.2 Interpretaci√≥n comparativa (CLAVE)**

**C√≥mo leer la tabla**

R¬≤ m√°s alto ‚Üí mejor capacidad explicativa

RMSE m√°s bajo ‚Üí menor error promedio

MAE m√°s bajo ‚Üí predicciones m√°s robustas

Normalmente observar√°s:

**üìâ Regresi√≥n Lineal**

Menor R¬≤

Mayor RMSE

Sirve como baseline interpretativo

**üå≥ Random Forest**

Mejora clara de R¬≤

Reduce error

Buen equilibrio precisi√≥n‚Äìrobustez

**üîµ Gradient Boosting**

R¬≤ similar o ligeramente superior

Error comparable o menor

Modelo m√°s complejo

**‚úÖ9.3 Selecci√≥n del modelo final**

**Criterios**

1. Desempe√±o predictivo (R¬≤, RMSE, MAE)

2. Estabilidad

3. Riesgo de sobreajuste

4. Interpretabilidad relativa

5. Utilidad para autoridades de salud

##‚ñ∂Ô∏è PASO 10 ‚Äî Predicci√≥n final y agregaci√≥n mensual

Objetivo:
Generar predicciones semanales por distrito usando el modelo final (Random Forest) y luego agregarlas a nivel mensual para priorizaci√≥n y prevenci√≥n.

**10.1 Convertir df_model a Pandas**
"""

df_model_pd = df_model.to_pandas()

"""**Crear el DataFrame de predicciones semanales**"""

df_preds = df_model_pd.loc[
    test_idx,
    ["distrito", "ano", "semana"]
].copy()

df_preds["ira_pred_semanal"] = y_pred_rf

df_preds.head()

"""**10.2 Crear variable MES**"""

df_preds["mes"] = ((df_preds["semana"] - 1) // 4) + 1

"""**10.3 Agregaci√≥n mensual**"""

pred_mensual = (
    df_preds
    .groupby(["distrito", "ano", "mes"], as_index=False)
    .agg({"ira_pred_semanal": "sum"})
    .rename(columns={"ira_pred_semanal": "ira_pred_mensual"})
)

"""**10.4 Ranking mensual**"""

ranking_mensual = pred_mensual.sort_values(
    "ira_pred_mensual", ascending=False
)

ranking_mensual.head(10)

"""##GRAFICOS:

**üîπ GR√ÅFICO 1 ‚Äî Tendencia temporal mensual de IRA (regi√≥n Arequipa)**

**Qu√© muestra**

La evoluci√≥n mensual total de IRA en Arequipa (agregado regional).

**Para qu√© sirve**

Evidencia estacionalidad

Justifica el uso de modelos temporales

Va en la secci√≥n Visualizaci√≥n Anal√≠tica
"""

import matplotlib.pyplot as plt
import polars as pl

# Agregar IRA a nivel regional por a√±o y semana
df_region = (
    df_model
    .group_by(["ano", "semana"])
    .agg(
        pl.col("total_ira").sum().alias("total_ira")
    )
    .sort(["ano", "semana"])
)

# Convertir a pandas solo para graficar
df_region_pd = df_region.to_pandas()

plt.figure()
plt.plot(
    range(len(df_region_pd)),
    df_region_pd["total_ira"]
)
plt.title("Evoluci√≥n semanal de casos de IRA en Arequipa")
plt.xlabel("Semanas")
plt.ylabel("Casos de IRA")
plt.tight_layout()
plt.savefig("fig_tendencia_ira.png")
plt.show()

"""## üîπGR√ÅFICO 2 ‚Äî Comparaci√≥n distrital de carga de IRA

Este gr√°fico cumple el rol del ‚ÄúAn√°lisis Provincial / Distrital‚Äù del art√≠culo ejemplo y sirve para:

Identificar qu√© distritos concentran mayor carga de IRA

Mostrar heterogeneidad territorial

Justificar por qu√© el modelado se hace a nivel distrital

Servir como base para el ranking de distritos cr√≠ticos
"""

import matplotlib.pyplot as plt
import polars as pl

# Agregaci√≥n: total de IRA por distrito
df_distrito = (
    df_model
    .group_by("distrito")
    .agg(
        pl.col("total_ira").sum().alias("total_ira")
    )
    .sort("total_ira", descending=True)
    .head(10)
)

# Convertimos a pandas para graficar
df_plot = df_distrito.to_pandas()

# Gr√°fico
plt.figure(figsize=(10, 6))
plt.barh(df_plot["distrito"], df_plot["total_ira"])
plt.xlabel("Total acumulado de casos de IRA")
plt.ylabel("Distrito")
plt.title("Distritos con mayor carga acumulada de IRA en Arequipa")
plt.gca().invert_yaxis()
plt.tight_layout()
plt.show()

plt.savefig("fig_distritos_ira.png", dpi=300)

"""##üîπGR√ÅFICO 3 ‚Äî Evoluci√≥n temporal de IRA por distritos clave

Mostrar c√≥mo evolucionan los casos de IRA en el tiempo para distritos seleccionados, permitiendo:

Comparar patrones temporales

Identificar estacionalidad com√∫n

Detectar diferencias en magnitud y variabilidad

Justificar el modelado predictivo por distrito
"""

import matplotlib.pyplot as plt

# Distritos seleccionados
distritos_sel = [
    "PAUCARPATA",
    "AREQUIPA",
    "CERRO COLORADO",
    "CAYMA",
    "YANAHUARA"
]

# Filtrar datos
df_plot = (
    df_model
    .filter(pl.col("distrito").is_in(distritos_sel))
    .select(["distrito", "ano", "semana", "total_ira"])
    .sort(["ano", "semana"])
)

# Crear √≠ndice temporal continuo
df_plot = df_plot.with_columns(
    (pl.col("ano") * 52 + pl.col("semana")).alias("t_index")
)

# Convertir a pandas solo para graficar
df_pd = df_plot.to_pandas()

# Gr√°fico
plt.figure(figsize=(12, 6))

for d in distritos_sel:
    subset = df_pd[df_pd["distrito"] == d]
    plt.plot(
        subset["t_index"],
        subset["total_ira"],
        label=d,
        linewidth=2
    )

plt.title("Evoluci√≥n temporal de casos de IRA por distritos seleccionados ‚Äì Arequipa")
plt.xlabel("Tiempo (semanas acumuladas)")
plt.ylabel("Casos de IRA")
plt.legend()
plt.grid(alpha=0.3)

plt.tight_layout()
plt.savefig("fig_evolucion_distritos_ira.png", dpi=300)
plt.show()

"""##GR√ÅFICO 4 ‚Äî Ranking de distritos con mayor carga esperada de IRA (Predicci√≥n)"""

df_preds.head()

df_preds_pd.columns

# Agregaci√≥n mensual de predicciones
df_pred_mensual = (
    df_preds_pd
    .groupby(["distrito", "ano", "mes"], as_index=False)
    ["ira_pred_semanal"]
    .sum()
)

df_rank = (
    df_pred_mensual
    .groupby("distrito", as_index=False)
    ["ira_pred_semanal"]
    .mean()
    .sort_values("ira_pred_semanal", ascending=False)
)

df_rank.head(10)

top10 = df_rank.head(10)

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))

plt.barh(
    top10["distrito"],
    top10["ira_pred_semanal"]
)

plt.xlabel("Casos de IRA predichos (promedio mensual)")
plt.ylabel("Distrito")
plt.title("Ranking de distritos con mayor carga esperada de IRA ‚Äì Arequipa")

plt.gca().invert_yaxis()
plt.tight_layout()
plt.show()
plt.savefig("fig_ranking_prediccion_ira.png", dpi=300, bbox_inches="tight")

"""##üü¢ GR√ÅFICO 5 ‚Äî Importancia de Variables del Modelo"""



[name for name in globals() if "model" in name.lower() or "rf" in name.lower() or "gb" in name.lower()]

X_columns = df_model_pd.drop(
    columns=["target_ira_t1"],  # o la variable objetivo que usaste
    errors="ignore"
).columns

len(X_columns), len(importances_gbr)

df_model_pd.columns

X_columns = df_model_pd.columns  # Esto asegura que tomes todas las columnas disponibles

feature_names = [
    "ano",
    "semana",
    "total_ira",
    "temp_mean",
    "temp_max",
    "temp_min",
    "humedad_mean",
    "precipitacion_sum",
    "ira_lag1",
    "ira_lag2",
    "ira_lag4",
    # si entrenaste con 12, y falta una:
    # elimina "total_ira" si no la usaste como predictor
]

len(feature_names), len(importances_gbr)

gbr.n_features_in_

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Importancias del modelo (ya confirmadas: 118)
importances = importances_gbr

# Agrupaci√≥n conceptual (alineada con el dise√±o del modelo)
groups = {
    "Lags epidemiol√≥gicos": np.mean(importances[-3:]),        # ira_lag1, ira_lag2, ira_lag4
    "Variables clim√°ticas": np.mean(importances[3:8]),        # temp, humedad, precip
    "Variables temporales": np.mean(importances[:2]),         # a√±o, semana
}

df_importance_grouped = pd.DataFrame(
    list(groups.items()),
    columns=["Grupo de variables", "Importancia relativa"]
).sort_values("Importancia relativa", ascending=False)

df_importance_grouped

plt.figure(figsize=(7, 4))
plt.barh(
    df_importance_grouped["Grupo de variables"],
    df_importance_grouped["Importancia relativa"]
)
plt.gca().invert_yaxis()
plt.xlabel("Importancia relativa promedio")
plt.title("Importancia relativa de grupos de variables\nModelo Gradient Boosting")
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Variable real
y_real = df_model_pd["total_ira"].values

# Variable predicha (Gradient Boosting)
y_pred = y_pred_gbr

len(y_test), len(y_pred_gbr)

plt.figure(figsize=(7, 7))

plt.scatter(
    y_test,
    y_pred_gbr,
    alpha=0.4
)

# L√≠nea ideal y = x
max_val = max(y_test.max(), y_pred_gbr.max())
plt.plot([0, max_val], [0, max_val], linestyle="--")

plt.xlabel("Casos reales de IRA")
plt.ylabel("Casos predichos de IRA")
plt.title("Comparaci√≥n entre valores reales y predichos\nModelo Gradient Boosting")

plt.tight_layout()
plt.savefig("fig_real_vs_predicho.png", dpi=300)
plt.show()